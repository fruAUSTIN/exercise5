{"version":3,"names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t// Require module\n\t__webpack_require__(1);\n\t__webpack_require__(3);\n\t__webpack_require__(19);\n\t\n\tvar oTabs = window.oTabs = __webpack_require__(25);\n\t\n\t//const oExpanderObjects = window.oExpanderObjects = oExpander.init(document.body, {})\n\t\n\tvar tabsObjects = window.tabsObjects = oTabs.init(document.body, {\n\t\tdisablefocus: false\n\t});\n\t\n\t// Wait until the page has loaded\n\tif (document.readyState === 'interactive' || document.readyState === 'complete') {\n\t\tdocument.dispatchEvent(new CustomEvent('o.DOMContentLoaded'));\n\t}\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t// Dispatch a custom event that will tell all required modules to initialise\n\t\tdocument.dispatchEvent(new CustomEvent('o.DOMContentLoaded'));\n\t});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\tvar define = false;\n\t\n\t/*global module*/\n\t\n\t/**\n\t * Detect IE 8 through injected conditional comments:\n\t * no UA detection, no need for conditional compilation or JS check\n\t * @return {Bool} true if the browser is IE 8\n\t */\n\tvar isIE8 = (function () {\n\t\tvar b = document.createElement('B');\n\t\tvar docElem = document.documentElement;\n\t\tvar isIE = undefined;\n\t\n\t\tb.innerHTML = '<!--[if IE 8]><b id=\"ie8test\"></b><![endif]-->';\n\t\tdocElem.appendChild(b);\n\t\tisIE = !!document.getElementById('ie8test');\n\t\tdocElem.removeChild(b);\n\t\treturn isIE;\n\t})();\n\t\n\t/**\n\t * Grab grid properties\n\t * @return {Object} layout names and gutter widths\n\t */\n\tfunction getGridProperties() {\n\t\treturn getGridFromDoc('after');\n\t}\n\t\n\t/**\n\t * Get all layout sizes\n\t * @return {Object} layout names and sizes\n\t */\n\tfunction getGridBreakpoints() {\n\t\treturn getGridFromDoc('before');\n\t}\n\t\n\t/**\n\t * Grab grid properties surfaced in html:after and html:before's content\n\t * @param {String} position Whether to get all properties in :before, or current properties in :after\n\t * @return {Object} layout names and gutter widths\n\t */\n\tfunction getGridFromDoc(position) {\n\t\t// Contained in a try/catch as it should not error if o-grid styles are not (deliberately or accidentally) loaded\n\t\t// e.g. o-tracking will always try to read this property, but the page is not obliged to use o-grid for layout\n\t\ttry {\n\t\t\tvar gridProperties = window.getComputedStyle(document.documentElement, ':' + position).getPropertyValue('content');\n\t\t\t// Firefox computes: \"{\\\"foo\\\": \\\"bar\\\"}\"\n\t\t\t// We want readable JSON: {\"foo\": \"bar\"}\n\t\t\tgridProperties = gridProperties.replace(/'/g, '').replace(/\\\\/g, '').replace(/^\"/, '').replace(/\"$/, '');\n\t\t\treturn JSON.parse(gridProperties);\n\t\t} catch (e) {\n\t\t\treturn {};\n\t\t}\n\t}\n\t\n\t/**\n\t * Grab the current layout\n\t * @return {String} Layout name\n\t */\n\tfunction getCurrentLayout() {\n\t\tif (isIE8) {\n\t\t\treturn 'L';\n\t\t}\n\t\n\t\treturn getGridProperties().layout;\n\t}\n\t\n\t/**\n\t * Grab the current space between columns\n\t * @return {String} Gutter width in pixels\n\t */\n\tfunction getCurrentGutter() {\n\t\tif (isIE8) {\n\t\t\treturn '20px';\n\t\t}\n\t\n\t\treturn getGridProperties().gutter;\n\t}\n\t\n\t/**\n\t * This sets MediaQueryListeners on all the o-grid breakpoints\n\t * and fires a `o-grid.layoutChange` event on layout change.\n\t */\n\tfunction enableLayoutChangeEvents() {\n\t\t// Create a map containing all breakpoints exposed via html:before\n\t\tvar gridLayouts = getGridBreakpoints();\n\t\tif (gridLayouts.hasOwnProperty('layouts')) {\n\t\t\t(function () {\n\t\t\t\tvar layouts = gridLayouts.layouts;\n\t\t\t\tvar breakpoints = new Map(Object.keys(layouts).map(function (key) {\n\t\t\t\t\treturn [key, layouts[key]];\n\t\t\t\t}));\n\t\t\t\tvar decr1 = function decr1(val) {\n\t\t\t\t\treturn Number(val.replace('px', '') - 1) + 'px';\n\t\t\t\t};\n\t\n\t\t\t\t// Generate media queries for each\n\t\t\t\tbreakpoints.forEach(function (width, size) {\n\t\t\t\t\tvar queries = [];\n\t\t\t\t\tif (size === 'S') {\n\t\t\t\t\t\tqueries.push('(max-width: ' + width + ')');\n\t\t\t\t\t\tqueries.push('(min-width: ' + width + ') and (max-width: ' + decr1(breakpoints.get('M')) + ')');\n\t\t\t\t\t} else if (size === 'M') {\n\t\t\t\t\t\tqueries.push('(min-width: ' + width + ') and (max-width: ' + decr1(breakpoints.get('L')) + ')');\n\t\t\t\t\t} else if (size === 'L') {\n\t\t\t\t\t\tqueries.push('(min-width: ' + width + ') and (max-width: ' + decr1(breakpoints.get('XL')) + ')');\n\t\t\t\t\t} else if (size === 'XL') {\n\t\t\t\t\t\tqueries.push('(min-width: ' + width + ')');\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// matchMedia listener handler: Dispatch `o-grid.layoutChange` event if a match\n\t\t\t\t\tvar handleMQChange = function handleMQChange(mql) {\n\t\t\t\t\t\tif (mql.matches) {\n\t\t\t\t\t\t\twindow.dispatchEvent(new CustomEvent('o-grid.layoutChange', {\n\t\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\t\tlayout: size\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Create a new listener for each layout\n\t\t\t\t\tqueries.forEach(function (mq) {\n\t\t\t\t\t\tvar mql = window.matchMedia(mq);\n\t\t\t\t\t\tmql.addListener(handleMQChange);\n\t\t\t\t\t\thandleMQChange(mql);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})();\n\t\t} else {\n\t\t\tconsole.error('To enable grid layout change events, include oGridSurfaceLayoutSizes in your Sass');\n\t\t}\n\t}\n\t\n\texports['default'] = {\n\t\tgetCurrentLayout: getCurrentLayout,\n\t\tgetCurrentGutter: getCurrentGutter,\n\t\tgetGridBreakpoints: getGridBreakpoints,\n\t\tenableLayoutChangeEvents: enableLayoutChangeEvents\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(4);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require,module*/\n\t\n\tvar oHierarchicalNav = __webpack_require__(5);\n\tvar constructAll = function constructAll() {\n\t\toHierarchicalNav.init();\n\t\tdocument.removeEventListener('o.DOMContentLoaded', constructAll);\n\t};\n\tdocument.addEventListener('o.DOMContentLoaded', constructAll);\n\t\n\tmodule.exports = oHierarchicalNav;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require,module,document,HTMLElement*/\n\t\n\tvar SquishyList = __webpack_require__(6);\n\tvar DomDelegate = __webpack_require__(8);\n\tvar oViewport = __webpack_require__(10);\n\tvar Nav = __webpack_require__(15);\n\t\n\tfunction ResponsiveNav(rootEl) {\n\t\n\t\tvar rootDelegate = undefined;\n\t\tvar nav = undefined;\n\t\tvar contentFilterEl = undefined;\n\t\tvar contentFilter = undefined;\n\t\tvar moreEl = undefined;\n\t\tvar moreListEl = undefined;\n\t\tvar clonedIdPrefix = 'o-hierarchical-nav__cloned-id-';\n\t\tvar prefixedNodes = [];\n\t\n\t\t// Check if element is a controller of another DOM element\n\t\tfunction isMegaDropdownControl(el) {\n\t\t\treturn el && el.hasAttribute('aria-controls');\n\t\t}\n\t\n\t\t// On resize, apply o-squishy-list, and, if it has a sub-level dom, populate more list\n\t\tfunction resize() {\n\t\t\tnav.resize();\n\t\n\t\t\tif (contentFilter) {\n\t\t\t\tcontentFilter.squish();\n\t\t\t\tif (!isMegaDropdownControl(moreEl)) {\n\t\t\t\t\tpopulateMoreList(contentFilter.getHiddenItems());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Empty the more list\n\t\tfunction emptyMoreList() {\n\t\t\tif (moreListEl) {\n\t\t\t\tmoreListEl.innerHTML = '';\n\t\t\t}\n\t\t}\n\t\n\t\t// Get the information from the element and create a new li tag with the element's text to append more list\n\t\tfunction addItemToMoreList(text, href) {\n\t\t\tvar itemEl = document.createElement('li');\n\t\t\tvar aEl = document.createElement('a');\n\t\n\t\t\tif (typeof aEl.textContent !== 'undefined') {\n\t\t\t\taEl.textContent = text;\n\t\t\t} else {\n\t\t\t\taEl.innerText = text;\n\t\t\t}\n\t\n\t\t\taEl.href = href;\n\t\t\titemEl.appendChild(aEl);\n\t\t\tmoreListEl.appendChild(itemEl);\n\t\t}\n\t\n\t\tfunction cloneItemToMoreList(el) {\n\t\t\tvar cloneEl = el.cloneNode(true);\n\t\t\t// remove the attributes that are only applicable to higher level\n\t\t\tcloneEl.removeAttribute('data-priority');\n\t\t\tcloneEl.removeAttribute('aria-hidden');\n\t\t\tcloneEl.removeAttribute('data-o-hierarchical-nav-is-cloneable');\n\t\t\t// recurse through children and amend any id values to maintain uniqueness\n\t\t\tprefixIds(el);\n\t\n\t\t\t// increase level of nested menus\n\t\t\tincrementMenuDepths(cloneEl);\n\t\n\t\t\tmoreListEl.appendChild(cloneEl);\n\t\t}\n\t\n\t\tfunction resetIds() {\n\t\t\tvar nextNode = undefined;\n\t\t\twhile (prefixedNodes.length > 0) {\n\t\t\t\tnextNode = prefixedNodes.pop();\n\t\t\t\tnextNode.setAttribute('id', nextNode.getAttribute('id').replace(clonedIdPrefix, ''));\n\t\t\t}\n\t\t}\n\t\n\t\tfunction incrementMenuDepths(el) {\n\t\t\t// data-o-hierarchical-nav-level attribute is incremented by one for each\n\t\t\t// of the children recursively. Modifies elements in place, assumes\n\t\t\t// cloned element to be passed in.\n\t\t\tvar child = undefined;\n\t\t\tif (el.hasChildNodes()) {\n\t\t\t\tvar children = el.childNodes;\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchild = children[i];\n\t\t\t\t\tif (child instanceof HTMLElement) {\n\t\t\t\t\t\tif (child.hasAttribute('data-o-hierarchical-nav-level')) {\n\t\t\t\t\t\t\t// increment nav-level when attribute present\n\t\t\t\t\t\t\tvar origNavLevel = parseInt(child.getAttribute('data-o-hierarchical-nav-level'), 10);\n\t\t\t\t\t\t\tvar updatedNavLevel = (isNaN(origNavLevel) ? 0 : origNavLevel) + 1;\n\t\t\t\t\t\t\tchild.setAttribute('data-o-hierarchical-nav-level', updatedNavLevel);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementMenuDepths(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction prefixIds(el) {\n\t\t\t// id's are prefixed to ensure that any id based functionality uses the visible element\n\t\t\t// for example a 'label' tag with a 'for' attribute will not find the correct input it\n\t\t\t// relates to as it uses the first matching id in the document\n\t\t\tvar child = undefined;\n\t\t\tif (el.hasChildNodes()) {\n\t\t\t\tvar children = el.childNodes;\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchild = children[i];\n\t\t\t\t\tif (child instanceof HTMLElement) {\n\t\t\t\t\t\tif (child.hasAttribute('id')) {\n\t\t\t\t\t\t\tprefixedNodes.push(child); // store to make the cleanup more performant\n\t\t\t\t\t\t\tchild.setAttribute('id', clonedIdPrefix + child.getAttribute('id'));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprefixIds(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// For every hidden item, add it to the more list\n\t\tfunction populateMoreList(hiddenEls) {\n\t\t\temptyMoreList();\n\t\t\tresetIds();\n\t\n\t\t\tfor (var c = 0, l = hiddenEls.length; c < l; c++) {\n\t\t\t\tvar aEl = hiddenEls[c].querySelector('a');\n\t\t\t\tvar ulEl = hiddenEls[c].querySelector('ul');\n\t\n\t\t\t\tif (hiddenEls[c].hasAttribute('data-o-hierarchical-nav-is-cloneable')) {\n\t\t\t\t\tcloneItemToMoreList(hiddenEls[c]);\n\t\t\t\t} else {\n\t\t\t\t\tvar aText = typeof aEl.textContent !== 'undefined' ? aEl.textContent : aEl.innerText;\n\t\t\t\t\taddItemToMoreList(aText, aEl.href, ulEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// If all elements are hidden, add the all modifier, if not, the some modifier\n\t\tfunction setMoreElClass(remainingItems) {\n\t\t\tif (!moreEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (remainingItems === 0) {\n\t\t\t\tmoreEl.classList.add('o-hierarchical-nav__more--all');\n\t\t\t\tmoreEl.classList.remove('o-hierarchical-nav__more--some');\n\t\t\t} else {\n\t\t\t\tmoreEl.classList.add('o-hierarchical-nav__more--some');\n\t\t\t\tmoreEl.classList.remove('o-hierarchical-nav__more--all');\n\t\t\t}\n\t\t}\n\t\n\t\t// When there's an o-squishy-list change, collapse all elements and run the setMoreElClass method with number of non-hidden elements\n\t\tfunction contentFilterChangeHandler(ev) {\n\t\t\tif (ev.target === contentFilterEl && ev.detail.hiddenItems.length > 0) {\n\t\t\t\tnav.collapseAll();\n\t\t\t\tsetMoreElClass(ev.detail.remainingItems.length);\n\t\t\t}\n\t\t}\n\t\n\t\t// If more button is clicked, populate it\n\t\tfunction navExpandHandler(ev) {\n\t\t\tif (ev.target === moreEl) {\n\t\t\t\tpopulateMoreList(contentFilter.getHiddenItems());\n\t\t\t}\n\t\t}\n\t\n\t\tfunction init() {\n\t\t\tif (!rootEl) {\n\t\t\t\trootEl = document.body;\n\t\t\t} else if (!(rootEl instanceof HTMLElement)) {\n\t\t\t\trootEl = document.querySelector(rootEl);\n\t\t\t}\n\t\n\t\t\tnav = new Nav(rootEl);\n\t\t\trootDelegate = new DomDelegate(rootEl);\n\t\t\tcontentFilterEl = rootEl.querySelector('ul');\n\t\t\tmoreEl = rootEl.querySelector('[data-more]');\n\t\n\t\t\tif (contentFilterEl) {\n\t\t\t\tcontentFilter = new SquishyList(contentFilterEl, { filterOnResize: false });\n\t\t\t}\n\t\n\t\t\t// If there's a more element, add a ul tag where hidden elements will be appended\n\t\t\tif (moreEl) {\n\t\t\t\tmoreEl.setAttribute('aria-hidden', 'true');\n\t\n\t\t\t\tif (!isMegaDropdownControl(moreEl)) {\n\t\t\t\t\tmoreListEl = document.createElement('ul');\n\t\t\t\t\tmoreListEl.setAttribute('data-o-hierarchical-nav-level', '2');\n\t\t\t\t\tmoreEl.appendChild(moreListEl);\n\t\t\t\t\trootDelegate.on('oLayers.new', navExpandHandler);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\trootDelegate.on('oSquishyList.change', contentFilterChangeHandler);\n\t\n\t\t\tvar bodyDelegate = new DomDelegate(document.body);\n\t\n\t\t\t// Force a resize when it loads, in case it loads on a smaller screen\n\t\t\tresize();\n\t\n\t\t\toViewport.listenTo('resize');\n\t\t\tbodyDelegate.on('oViewport.resize', resize);\n\t\t}\n\t\n\t\tfunction destroy() {\n\t\t\tprefixedNodes = [];\n\t\t\trootDelegate.destroy();\n\t\t\trootEl.removeAttribute('data-o-hierarchical-nav--js');\n\t\t}\n\t\n\t\tinit();\n\t\n\t\tthis.resize = resize;\n\t\tthis.destroy = destroy;\n\t}\n\t\n\t// Initializes all nav elements in the page or whatever element is passed to it\n\tResponsiveNav.init = function (el) {\n\t\tif (!el) {\n\t\t\tel = document.body;\n\t\t} else if (!(el instanceof HTMLElement)) {\n\t\t\tel = document.querySelector(el);\n\t\t}\n\t\n\t\tvar navEls = el.querySelectorAll('[data-o-component=\"o-hierarchical-nav\"]');\n\t\tvar responsiveNavs = [];\n\t\n\t\tfor (var c = 0, l = navEls.length; c < l; c++) {\n\t\t\tif (!navEls[c].hasAttribute('data-o-hierarchical-nav--js')) {\n\t\t\t\t// If it's a vertical nav, we don't need all the responsive methods\n\t\t\t\tif (navEls[c].getAttribute('data-o-hierarchical-nav-orientiation') === 'vertical') {\n\t\t\t\t\tresponsiveNavs.push(new Nav(navEls[c]));\n\t\t\t\t} else {\n\t\t\t\t\tresponsiveNavs.push(new ResponsiveNav(navEls[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn responsiveNavs;\n\t};\n\t\n\tmodule.exports = ResponsiveNav;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(7);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar define = false;\n\t\n\tvar SquishyList = (function () {\n\t\tfunction SquishyList(rootEl, opts) {\n\t\t\t_classCallCheck(this, SquishyList);\n\t\n\t\t\tthis.element = rootEl;\n\t\t\tthis.moreWidth = 0;\n\t\t\tthis.options = opts || { filterOnResize: true };\n\t\n\t\t\tthis.getPrioritySortedChildNodeEls();\n\t\t\tthis.moreEl = this.element.querySelector('[data-more]');\n\t\t\tif (this.moreEl) {\n\t\t\t\tthis.showEl(this.moreEl);\n\t\t\t\tthis.moreWidth = this.moreEl.offsetWidth;\n\t\t\t\tthis.hideEl(this.moreEl);\n\t\t\t}\n\t\t\tthis.squish();\n\t\t\tif (this.options.filterOnResize) {\n\t\t\t\twindow.addEventListener('resize', this.resizeHandler.bind(this), false);\n\t\t\t}\n\t\n\t\t\tthis.dispatchCustomEvent('oSquishyList.ready');\n\t\t}\n\t\n\t\t_createClass(SquishyList, [{\n\t\t\tkey: 'dispatchCustomEvent',\n\t\t\tvalue: function dispatchCustomEvent(name, data) {\n\t\t\t\tif (document.createEvent && this.element.dispatchEvent) {\n\t\t\t\t\tvar _event = document.createEvent('Event');\n\t\t\t\t\t_event.initEvent(name, true, true);\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\t_event.detail = data;\n\t\t\t\t\t}\n\t\t\t\t\tthis.element.dispatchEvent(_event);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getItemEls',\n\t\t\tvalue: function getItemEls() {\n\t\t\t\tvar itemEls = [];\n\t\t\t\tvar childNodeEl = undefined;\n\t\n\t\t\t\tfor (var c = 0, l = this.element.childNodes.length; c < l; c++) {\n\t\t\t\t\tchildNodeEl = this.element.childNodes[c];\n\t\n\t\t\t\t\t// Make it flexible so that other product and modules can manually hide elements and o-squishy-list won't add it to it's list\n\t\t\t\t\tif (childNodeEl.nodeType === 1 && !childNodeEl.hasAttribute('data-more') && !childNodeEl.hasAttribute('data-o-squishy-list--ignore')) {\n\t\t\t\t\t\titemEls.push(childNodeEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn itemEls;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'showEl',\n\t\t\tvalue: function showEl(el) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tif (el) {\n\t\t\t\t\tel.removeAttribute('aria-hidden');\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hideEl',\n\t\t\tvalue: function hideEl(el) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tif (el) {\n\t\t\t\t\tel.setAttribute('aria-hidden', 'true');\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getElPriority',\n\t\t\tvalue: function getElPriority(el) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\treturn parseInt(el.getAttribute('data-priority'), 10);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getPrioritySortedChildNodeEls',\n\t\t\tvalue: function getPrioritySortedChildNodeEls() {\n\t\t\t\tthis.allItemEls = this.getItemEls();\n\t\t\t\tthis.prioritySortedItemEls = [];\n\t\t\t\tvar unprioritisedItemEls = [];\n\t\t\t\tfor (var c = 0, l = this.allItemEls.length; c < l; c++) {\n\t\t\t\t\tvar thisItemEl = this.allItemEls[c];\n\t\t\t\t\tvar thisItemPriority = this.getElPriority(thisItemEl);\n\t\t\t\t\tif (isNaN(thisItemPriority)) {\n\t\t\t\t\t\tunprioritisedItemEls.push(thisItemEl);\n\t\t\t\t\t} else if (thisItemPriority >= 0) {\n\t\t\t\t\t\tif (!Array.isArray(this.prioritySortedItemEls[thisItemPriority])) {\n\t\t\t\t\t\t\tthis.prioritySortedItemEls[thisItemPriority] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.prioritySortedItemEls[thisItemPriority].push(thisItemEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (unprioritisedItemEls.length > 0) {\n\t\t\t\t\tthis.prioritySortedItemEls.push(unprioritisedItemEls);\n\t\t\t\t}\n\t\t\t\tthis.prioritySortedItemEls = this.prioritySortedItemEls.filter(function (v) {\n\t\t\t\t\treturn v !== undefined;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'showAllItems',\n\t\t\tvalue: function showAllItems() {\n\t\t\t\tthis.hiddenItemEls = [];\n\t\t\t\tfor (var c = 0, l = this.allItemEls.length; c < l; c++) {\n\t\t\t\t\tthis.showEl(this.allItemEls[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hideItems',\n\t\t\tvalue: function hideItems(els) {\n\t\t\t\t// We want highest priority items to be at the beginning of the array\n\t\t\t\tfor (var i = els.length - 1; i > -1; i--) {\n\t\t\t\t\tthis.hiddenItemEls.unshift(els[i]);\n\t\t\t\t\tthis.hideEl(els[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getVisibleContentWidth',\n\t\t\tvalue: function getVisibleContentWidth() {\n\t\t\t\tvar visibleItemsWidth = 0;\n\t\t\t\tfor (var c = 0, l = this.allItemEls.length; c < l; c++) {\n\t\t\t\t\tif (!this.allItemEls[c].hasAttribute('aria-hidden')) {\n\t\t\t\t\t\tvisibleItemsWidth += this.allItemEls[c].offsetWidth; // Needs to take into account margins too\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn visibleItemsWidth;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'doesContentFit',\n\t\t\tvalue: function doesContentFit() {\n\t\t\t\treturn this.getVisibleContentWidth() <= this.element.clientWidth;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getHiddenItems',\n\t\t\tvalue: function getHiddenItems() {\n\t\t\t\treturn this.hiddenItemEls;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getRemainingItems',\n\t\t\tvalue: function getRemainingItems() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\treturn this.allItemEls.filter(function (el) {\n\t\t\t\t\treturn _this.hiddenItemEls.indexOf(el) === -1;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'squish',\n\t\t\tvalue: function squish() {\n\t\t\t\tthis.showAllItems();\n\t\t\t\tif (this.doesContentFit()) {\n\t\t\t\t\tthis.hideEl(this.moreEl);\n\t\t\t\t} else {\n\t\t\t\t\tfor (var p = this.prioritySortedItemEls.length - 1; p >= 0; p--) {\n\t\t\t\t\t\tthis.hideItems(this.prioritySortedItemEls[p]);\n\t\t\t\t\t\tif (this.getVisibleContentWidth() + this.moreWidth <= this.element.clientWidth) {\n\t\t\t\t\t\t\tthis.showEl(this.moreEl);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.dispatchCustomEvent('oSquishyList.change', {\n\t\t\t\t\thiddenItems: this.getHiddenItems(),\n\t\t\t\t\tremainingItems: this.getRemainingItems()\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'resizeHandler',\n\t\t\tvalue: function resizeHandler() {\n\t\t\t\tclearTimeout(this.debounceTimeout);\n\t\t\t\tthis.debounceTimeout = setTimeout(this.squish.bind(this), 50);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'destroy',\n\t\t\tvalue: function destroy() {\n\t\t\t\tfor (var c = 0, l = this.allItemEls.length; c < l; c++) {\n\t\t\t\t\tthis.allItemEls[c].removeAttribute('aria-hidden');\n\t\t\t\t}\n\t\t\t\twindow.removeEventListener('resize', this.resizeHandler, false);\n\t\t\t\tthis.element.removeAttribute('data-o-squishy-list-js');\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'init',\n\t\t\tvalue: function init(el, opts) {\n\t\t\t\tif (!el) {\n\t\t\t\t\tel = document.body;\n\t\t\t\t}\n\t\t\t\tif (!(el instanceof HTMLElement)) {\n\t\t\t\t\tel = document.querySelector(el);\n\t\t\t\t}\n\t\t\t\tif (/\\bo-squishy-list\\b/.test(el.getAttribute('data-o-component'))) {\n\t\t\t\t\treturn new SquishyList(el, opts);\n\t\t\t\t}\n\t\t\t\treturn [].map.call(el.querySelectorAll('[data-o-component=\"o-squishy-list\"]'), function (el) {\n\t\t\t\t\treturn new SquishyList(el, opts);\n\t\t\t\t});\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn SquishyList;\n\t})();\n\t\n\texports['default'] = SquishyList;\n\t\n\tvar constructAll = function constructAll() {\n\t\tSquishyList.init();\n\t\tdocument.removeEventListener('o.DOMContentLoaded', constructAll);\n\t};\n\t\n\tif (typeof window !== 'undefined') {\n\t\tdocument.addEventListener('o.DOMContentLoaded', constructAll);\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(9);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*jshint browser:true, node:true*/\n\t\n\t'use strict';\n\t\n\tmodule.exports = Delegate;\n\t\n\t/**\n\t * DOM event delegator\n\t *\n\t * The delegator will listen\n\t * for events that bubble up\n\t * to the root node.\n\t *\n\t * @constructor\n\t * @param {Node|string} [root] The root node or a selector string matching the root node\n\t */\n\tfunction Delegate(root) {\n\t\n\t  /**\n\t   * Maintain a map of listener\n\t   * lists, keyed by event name.\n\t   *\n\t   * @type Object\n\t   */\n\t  this.listenerMap = [{}, {}];\n\t  if (root) {\n\t    this.root(root);\n\t  }\n\t\n\t  /** @type function() */\n\t  this.handle = Delegate.prototype.handle.bind(this);\n\t}\n\t\n\t/**\n\t * Start listening for events\n\t * on the provided DOM element\n\t *\n\t * @param  {Node|string} [root] The root node or a selector string matching the root node\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.root = function (root) {\n\t  var listenerMap = this.listenerMap;\n\t  var eventType;\n\t\n\t  // Remove master event listeners\n\t  if (this.rootElement) {\n\t    for (eventType in listenerMap[1]) {\n\t      if (listenerMap[1].hasOwnProperty(eventType)) {\n\t        this.rootElement.removeEventListener(eventType, this.handle, true);\n\t      }\n\t    }\n\t    for (eventType in listenerMap[0]) {\n\t      if (listenerMap[0].hasOwnProperty(eventType)) {\n\t        this.rootElement.removeEventListener(eventType, this.handle, false);\n\t      }\n\t    }\n\t  }\n\t\n\t  // If no root or root is not\n\t  // a dom node, then remove internal\n\t  // root reference and exit here\n\t  if (!root || !root.addEventListener) {\n\t    if (this.rootElement) {\n\t      delete this.rootElement;\n\t    }\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * The root node at which\n\t   * listeners are attached.\n\t   *\n\t   * @type Node\n\t   */\n\t  this.rootElement = root;\n\t\n\t  // Set up master event listeners\n\t  for (eventType in listenerMap[1]) {\n\t    if (listenerMap[1].hasOwnProperty(eventType)) {\n\t      this.rootElement.addEventListener(eventType, this.handle, true);\n\t    }\n\t  }\n\t  for (eventType in listenerMap[0]) {\n\t    if (listenerMap[0].hasOwnProperty(eventType)) {\n\t      this.rootElement.addEventListener(eventType, this.handle, false);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} eventType\n\t * @returns boolean\n\t */\n\tDelegate.prototype.captureForType = function (eventType) {\n\t  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;\n\t};\n\t\n\t/**\n\t * Attach a handler to one\n\t * event for all elements\n\t * that match the selector,\n\t * now or in the future\n\t *\n\t * The handler function receives\n\t * three arguments: the DOM event\n\t * object, the node that matched\n\t * the selector while the event\n\t * was bubbling and a reference\n\t * to itself. Within the handler,\n\t * 'this' is equal to the second\n\t * argument.\n\t *\n\t * The node that actually received\n\t * the event can be accessed via\n\t * 'event.target'.\n\t *\n\t * @param {string} eventType Listen for these events\n\t * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element\n\t * @param {function()} handler Handler function - event data passed here will be in event.data\n\t * @param {boolean} [useCapture] see 'useCapture' in <https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener>\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.on = function (eventType, selector, handler, useCapture) {\n\t  var root, listenerMap, matcher, matcherParam;\n\t\n\t  if (!eventType) {\n\t    throw new TypeError('Invalid event type: ' + eventType);\n\t  }\n\t\n\t  // handler can be passed as\n\t  // the second or third argument\n\t  if (typeof selector === 'function') {\n\t    useCapture = handler;\n\t    handler = selector;\n\t    selector = null;\n\t  }\n\t\n\t  // Fallback to sensible defaults\n\t  // if useCapture not set\n\t  if (useCapture === undefined) {\n\t    useCapture = this.captureForType(eventType);\n\t  }\n\t\n\t  if (typeof handler !== 'function') {\n\t    throw new TypeError('Handler must be a type of Function');\n\t  }\n\t\n\t  root = this.rootElement;\n\t  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\t\n\t  // Add master handler for type if not created yet\n\t  if (!listenerMap[eventType]) {\n\t    if (root) {\n\t      root.addEventListener(eventType, this.handle, useCapture);\n\t    }\n\t    listenerMap[eventType] = [];\n\t  }\n\t\n\t  if (!selector) {\n\t    matcherParam = null;\n\t\n\t    // COMPLEX - matchesRoot needs to have access to\n\t    // this.rootElement, so bind the function to this.\n\t    matcher = matchesRoot.bind(this);\n\t\n\t    // Compile a matcher for the given selector\n\t  } else if (/^[a-z]+$/i.test(selector)) {\n\t      matcherParam = selector;\n\t      matcher = matchesTag;\n\t    } else if (/^#[a-z0-9\\-_]+$/i.test(selector)) {\n\t      matcherParam = selector.slice(1);\n\t      matcher = matchesId;\n\t    } else {\n\t      matcherParam = selector;\n\t      matcher = matches;\n\t    }\n\t\n\t  // Add to the list of listeners\n\t  listenerMap[eventType].push({\n\t    selector: selector,\n\t    handler: handler,\n\t    matcher: matcher,\n\t    matcherParam: matcherParam\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove an event handler\n\t * for elements that match\n\t * the selector, forever\n\t *\n\t * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters\n\t * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n\t * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.off = function (eventType, selector, handler, useCapture) {\n\t  var i, listener, listenerMap, listenerList, singleEventType;\n\t\n\t  // Handler can be passed as\n\t  // the second or third argument\n\t  if (typeof selector === 'function') {\n\t    useCapture = handler;\n\t    handler = selector;\n\t    selector = null;\n\t  }\n\t\n\t  // If useCapture not set, remove\n\t  // all event listeners\n\t  if (useCapture === undefined) {\n\t    this.off(eventType, selector, handler, true);\n\t    this.off(eventType, selector, handler, false);\n\t    return this;\n\t  }\n\t\n\t  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\t  if (!eventType) {\n\t    for (singleEventType in listenerMap) {\n\t      if (listenerMap.hasOwnProperty(singleEventType)) {\n\t        this.off(singleEventType, selector, handler);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  listenerList = listenerMap[eventType];\n\t  if (!listenerList || !listenerList.length) {\n\t    return this;\n\t  }\n\t\n\t  // Remove only parameter matches\n\t  // if specified\n\t  for (i = listenerList.length - 1; i >= 0; i--) {\n\t    listener = listenerList[i];\n\t\n\t    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {\n\t      listenerList.splice(i, 1);\n\t    }\n\t  }\n\t\n\t  // All listeners removed\n\t  if (!listenerList.length) {\n\t    delete listenerMap[eventType];\n\t\n\t    // Remove the main handler\n\t    if (this.rootElement) {\n\t      this.rootElement.removeEventListener(eventType, this.handle, useCapture);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Handle an arbitrary event.\n\t *\n\t * @param {Event} event\n\t */\n\tDelegate.prototype.handle = function (event) {\n\t  var i,\n\t      l,\n\t      type = event.type,\n\t      root,\n\t      phase,\n\t      listener,\n\t      returned,\n\t      listenerList = [],\n\t      target,\n\t      /** @const */EVENTIGNORE = 'ftLabsDelegateIgnore';\n\t\n\t  if (event[EVENTIGNORE] === true) {\n\t    return;\n\t  }\n\t\n\t  target = event.target;\n\t\n\t  // Hardcode value of Node.TEXT_NODE\n\t  // as not defined in IE8\n\t  if (target.nodeType === 3) {\n\t    target = target.parentNode;\n\t  }\n\t\n\t  root = this.rootElement;\n\t\n\t  phase = event.eventPhase || (event.target !== event.currentTarget ? 3 : 2);\n\t\n\t  switch (phase) {\n\t    case 1:\n\t      //Event.CAPTURING_PHASE:\n\t      listenerList = this.listenerMap[1][type];\n\t      break;\n\t    case 2:\n\t      //Event.AT_TARGET:\n\t      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);\n\t      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);\n\t      break;\n\t    case 3:\n\t      //Event.BUBBLING_PHASE:\n\t      listenerList = this.listenerMap[0][type];\n\t      break;\n\t  }\n\t\n\t  // Need to continuously check\n\t  // that the specific list is\n\t  // still populated in case one\n\t  // of the callbacks actually\n\t  // causes the list to be destroyed.\n\t  l = listenerList.length;\n\t  while (target && l) {\n\t    for (i = 0; i < l; i++) {\n\t      listener = listenerList[i];\n\t\n\t      // Bail from this loop if\n\t      // the length changed and\n\t      // no more listeners are\n\t      // defined between i and l.\n\t      if (!listener) {\n\t        break;\n\t      }\n\t\n\t      // Check for match and fire\n\t      // the event if there's one\n\t      //\n\t      // TODO:MCG:20120117: Need a way\n\t      // to check if event#stopImmediatePropagation\n\t      // was called. If so, break both loops.\n\t      if (listener.matcher.call(target, listener.matcherParam, target)) {\n\t        returned = this.fire(event, target, listener);\n\t      }\n\t\n\t      // Stop propagation to subsequent\n\t      // callbacks if the callback returned\n\t      // false\n\t      if (returned === false) {\n\t        event[EVENTIGNORE] = true;\n\t        event.preventDefault();\n\t        return;\n\t      }\n\t    }\n\t\n\t    // TODO:MCG:20120117: Need a way to\n\t    // check if event#stopPropagation\n\t    // was called. If so, break looping\n\t    // through the DOM. Stop if the\n\t    // delegation root has been reached\n\t    if (target === root) {\n\t      break;\n\t    }\n\t\n\t    l = listenerList.length;\n\t    target = target.parentElement;\n\t  }\n\t};\n\t\n\t/**\n\t * Fire a listener on a target.\n\t *\n\t * @param {Event} event\n\t * @param {Node} target\n\t * @param {Object} listener\n\t * @returns {boolean}\n\t */\n\tDelegate.prototype.fire = function (event, target, listener) {\n\t  return listener.handler.call(target, event, target);\n\t};\n\t\n\t/**\n\t * Check whether an element\n\t * matches a generic selector.\n\t *\n\t * @type function()\n\t * @param {string} selector A CSS selector\n\t */\n\tvar matches = (function (el) {\n\t  if (!el) return;\n\t  var p = el.prototype;\n\t  return p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;\n\t})(Element);\n\t\n\t/**\n\t * Check whether an element\n\t * matches a tag selector.\n\t *\n\t * Tags are NOT case-sensitive,\n\t * except in XML (and XML-based\n\t * languages such as XHTML).\n\t *\n\t * @param {string} tagName The tag name to test against\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesTag(tagName, element) {\n\t  return tagName.toLowerCase() === element.tagName.toLowerCase();\n\t}\n\t\n\t/**\n\t * Check whether an element\n\t * matches the root.\n\t *\n\t * @param {?String} selector In this case this is always passed through as null and not used\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesRoot(selector, element) {\n\t  /*jshint validthis:true*/\n\t  if (this.rootElement === window) return element === document;\n\t  return this.rootElement === element;\n\t}\n\t\n\t/**\n\t * Check whether the ID of\n\t * the element in 'this'\n\t * matches the given ID.\n\t *\n\t * IDs are case-sensitive.\n\t *\n\t * @param {string} id The ID to test against\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesId(id, element) {\n\t  return id === element.id;\n\t}\n\t\n\t/**\n\t * Short hand for off()\n\t * and root(), ie both\n\t * with no parameters\n\t *\n\t * @return void\n\t */\n\tDelegate.prototype.destroy = function () {\n\t  this.off();\n\t  this.root();\n\t};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(11);\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t// let debug;\n\tvar utils = __webpack_require__(12);\n\tvar throttle = utils.throttle;\n\tvar debounce = utils.debounce;\n\t\n\tvar listeners = {};\n\tvar intervals = {\n\t\tresize: 100,\n\t\torientation: 100,\n\t\tvisibility: 100,\n\t\tscroll: 100\n\t};\n\t\n\tfunction setThrottleInterval(eventType, interval) {\n\t\tif (typeof arguments[0] === 'number') {\n\t\t\tsetThrottleInterval('scroll', arguments[0]);\n\t\t\tsetThrottleInterval('resize', arguments[1]);\n\t\t\tsetThrottleInterval('orientation', arguments[2]);\n\t\t\tsetThrottleInterval('visibility', arguments[3]);\n\t\t} else if (interval) {\n\t\t\tintervals[eventType] = interval;\n\t\t}\n\t}\n\t\n\tfunction listenToResize() {\n\t\tif (listeners.resize) {\n\t\t\treturn;\n\t\t}\n\t\tvar eventType = 'resize';\n\t\tvar handler = debounce(function (ev) {\n\t\t\tutils.broadcast('resize', {\n\t\t\t\tviewport: utils.getSize(),\n\t\t\t\toriginalEvent: ev\n\t\t\t});\n\t\t}, intervals.resize);\n\t\n\t\twindow.addEventListener(eventType, handler);\n\t\tlisteners.resize = {\n\t\t\teventType: eventType,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t\n\tfunction listenToOrientation() {\n\t\n\t\tif (listeners.orientation) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tvar eventType = 'orientationchange';\n\t\tvar handler = debounce(function (ev) {\n\t\t\tutils.broadcast('orientation', {\n\t\t\t\tviewport: utils.getSize(),\n\t\t\t\torientation: utils.getOrientation(),\n\t\t\t\toriginalEvent: ev\n\t\t\t});\n\t\t}, intervals.orientation);\n\t\n\t\twindow.addEventListener(eventType, handler);\n\t\tlisteners.orientation = {\n\t\t\teventType: eventType,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t\n\tfunction listenToVisibility() {\n\t\n\t\tif (listeners.visibility) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tvar eventType = utils.detectVisiblityAPI().eventType;\n\t\tvar handler = debounce(function (ev) {\n\t\t\tutils.broadcast('visibility', {\n\t\t\t\thidden: utils.getVisibility(),\n\t\t\t\toriginalEvent: ev\n\t\t\t});\n\t\t}, intervals.visibility);\n\t\n\t\twindow.addEventListener(eventType, handler);\n\t\n\t\tlisteners.visibility = {\n\t\t\teventType: eventType,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t\n\tfunction listenToScroll() {\n\t\n\t\tif (listeners.scroll) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tvar eventType = 'scroll';\n\t\tvar handler = throttle(function (ev) {\n\t\t\tvar scrollPos = utils.getScrollPosition();\n\t\t\tutils.broadcast('scroll', {\n\t\t\t\tviewport: utils.getSize(),\n\t\t\t\tscrollHeight: scrollPos.height,\n\t\t\t\tscrollLeft: scrollPos.left,\n\t\t\t\tscrollTop: scrollPos.top,\n\t\t\t\tscrollWidth: scrollPos.width,\n\t\t\t\toriginalEvent: ev\n\t\t\t});\n\t\t}, intervals.scroll);\n\t\n\t\twindow.addEventListener(eventType, handler);\n\t\tlisteners.scroll = {\n\t\t\teventType: eventType,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t\n\tfunction listenTo(eventType) {\n\t\tif (eventType === 'resize' || eventType === 'all') {\n\t\t\tlistenToResize();\n\t\t}\n\t\n\t\tif (eventType === 'scroll' || eventType === 'all') {\n\t\t\tlistenToScroll();\n\t\t}\n\t\n\t\tif (eventType === 'orientation' || eventType === 'all') {\n\t\t\tlistenToOrientation();\n\t\t}\n\t\n\t\tif (eventType === 'visibility' || eventType === 'all') {\n\t\t\tlistenToVisibility();\n\t\t}\n\t}\n\t\n\tfunction stopListeningTo(eventType) {\n\t\tif (eventType === 'all') {\n\t\t\tObject.keys(listeners).forEach(stopListeningTo);\n\t\t} else if (listeners[eventType]) {\n\t\t\twindow.removeEventListener(listeners[eventType].eventType, listeners[eventType].handler);\n\t\t\tdelete listeners[eventType];\n\t\t}\n\t}\n\t\n\tmodule.exports = {\n\t\tdebug: function debug() {\n\t\t\t// debug = true;\n\t\t\tutils.debug();\n\t\t},\n\t\tlistenTo: listenTo,\n\t\tstopListeningTo: stopListeningTo,\n\t\tsetThrottleInterval: setThrottleInterval,\n\t\tgetOrientation: utils.getOrientation,\n\t\tgetSize: utils.getSize,\n\t\tgetScrollPosition: utils.getScrollPosition,\n\t\tgetVisibility: utils.getVisibility\n\t};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/* jshint devel: true */\n\tvar oUtils = __webpack_require__(13);\n\t\n\tvar _debug = undefined;\n\t\n\tfunction broadcast(eventType, data, target) {\n\t\ttarget = target || document.body;\n\t\n\t\tif (_debug) {\n\t\t\tconsole.log('o-viewport', eventType, data);\n\t\t}\n\t\n\t\ttarget.dispatchEvent(new CustomEvent('oViewport.' + eventType, {\n\t\t\tdetail: data,\n\t\t\tbubbles: true\n\t\t}));\n\t}\n\t\n\tfunction getHeight(ignoreScrollbars) {\n\t\treturn ignoreScrollbars ? document.documentElement.clientHeight : Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n\t}\n\t\n\tfunction getWidth(ignoreScrollbars) {\n\t\treturn ignoreScrollbars ? document.documentElement.clientWidth : Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n\t}\n\t\n\tfunction getSize(ignoreScrollbars) {\n\t\treturn {\n\t\t\theight: module.exports.getHeight(ignoreScrollbars),\n\t\t\twidth: module.exports.getWidth(ignoreScrollbars)\n\t\t};\n\t}\n\t\n\tfunction getScrollPosition() {\n\t\tvar de = document.documentElement;\n\t\tvar db = document.body;\n\t\n\t\t// adapted from https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY\n\t\tvar isCSS1Compat = (document.compatMode || '') === 'CSS1Compat';\n\t\n\t\tvar ieX = isCSS1Compat ? de.scrollLeft : db.scrollLeft;\n\t\tvar ieY = isCSS1Compat ? de.scrollTop : db.scrollTop;\n\t\treturn {\n\t\t\theight: db.scrollHeight,\n\t\t\twidth: db.scrollWidth,\n\t\t\tleft: window.pageXOffset || window.scrollX || ieX,\n\t\t\ttop: window.pageYOffset || window.scrollY || ieY\n\t\t};\n\t}\n\t\n\tfunction getOrientation() {\n\t\tvar orientation = window.screen.orientation || window.screen.mozOrientation || window.screen.msOrientation || undefined;\n\t\tif (orientation) {\n\t\t\treturn typeof orientation === 'string' ? orientation.split('-')[0] : orientation.type.split('-')[0];\n\t\t} else if (window.matchMedia) {\n\t\t\treturn window.matchMedia('(orientation: portrait)').matches ? 'portrait' : 'landscape';\n\t\t} else {\n\t\t\treturn getHeight() >= getWidth() ? 'portrait' : 'landscape';\n\t\t}\n\t}\n\t\n\tfunction detectVisiblityAPI() {\n\t\tvar hiddenName = undefined;\n\t\tvar eventType = undefined;\n\t\tif (typeof document.hidden !== 'undefined') {\n\t\t\thiddenName = 'hidden';\n\t\t\teventType = 'visibilitychange';\n\t\t} else if (typeof document.mozHidden !== 'undefined') {\n\t\t\thiddenName = 'mozHidden';\n\t\t\teventType = 'mozvisibilitychange';\n\t\t} else if (typeof document.msHidden !== 'undefined') {\n\t\t\thiddenName = 'msHidden';\n\t\t\teventType = 'msvisibilitychange';\n\t\t} else if (typeof document.webkitHidden !== 'undefined') {\n\t\t\thiddenName = 'webkitHidden';\n\t\t\teventType = 'webkitvisibilitychange';\n\t\t}\n\t\n\t\treturn {\n\t\t\thiddenName: hiddenName,\n\t\t\teventType: eventType\n\t\t};\n\t}\n\t\n\tfunction getVisibility() {\n\t\tvar hiddenName = detectVisiblityAPI().hiddenName;\n\t\treturn document[hiddenName];\n\t}\n\t\n\tmodule.exports = {\n\t\tdebug: function debug() {\n\t\t\t_debug = true;\n\t\t},\n\t\tbroadcast: broadcast,\n\t\tgetWidth: getWidth,\n\t\tgetHeight: getHeight,\n\t\tgetSize: getSize,\n\t\tgetScrollPosition: getScrollPosition,\n\t\tgetVisibility: getVisibility,\n\t\tgetOrientation: getOrientation,\n\t\tdetectVisiblityAPI: detectVisiblityAPI,\n\t\tdebounce: oUtils.debounce,\n\t\tthrottle: oUtils.throttle\n\t};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(14);\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\tvar define = false;\n\t\n\t/**\n\t*\n\t* Debounces function so it is only called after n milliseconds\n\t* without it not being called\n\t*\n\t* @example\n\t* Utils.debounce(myFunction() {}, 100);\n\t*\n\t* @param {Function} func - Function to be debounced\n\t* @param {number} wait - Time in miliseconds\n\t*\n\t* @returns {Function} - Debounced function\n\t*/\n\tfunction debounce(func, wait) {\n\t\tvar timeout = undefined;\n\t\treturn function () {\n\t\t\tvar _this = this;\n\t\n\t\t\tvar args = arguments;\n\t\t\tvar later = function later() {\n\t\t\t\ttimeout = null;\n\t\t\t\tfunc.apply(_this, args);\n\t\t\t};\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(later, wait);\n\t\t};\n\t}\n\t\n\t/**\n\t*\n\t* Throttle function so it is only called once every n milliseconds\n\t*\n\t* @example\n\t* Utils.throttle(myFunction() {}, 100);\n\t*\n\t* @param {Function} func - Function to be throttled\n\t* @param {number} wait - Time in miliseconds\n\t*\n\t* @returns {Function} - Throttled function\n\t*/\n\tfunction throttle(func, wait) {\n\t\tvar timeout = undefined;\n\t\treturn function () {\n\t\t\tvar _this2 = this;\n\t\n\t\t\tif (timeout) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar args = arguments;\n\t\t\tvar later = function later() {\n\t\t\t\ttimeout = null;\n\t\t\t\tfunc.apply(_this2, args);\n\t\t\t};\n\t\n\t\t\ttimeout = setTimeout(later, wait);\n\t\t};\n\t}\n\t\n\texports.debounce = debounce;\n\texports.throttle = throttle;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require, module*/\n\t\n\tvar DomDelegate = __webpack_require__(8);\n\tvar oDom = __webpack_require__(16);\n\tvar utils = __webpack_require__(18);\n\t\n\tfunction Nav(rootEl) {\n\t\n\t\tvar bodyDelegate = new DomDelegate(document.body);\n\t\tvar rootDelegate = new DomDelegate(rootEl);\n\t\n\t\t// Get sub-level element\n\t\tfunction getChildListEl(el) {\n\t\t\treturn el.querySelector('ul');\n\t\t}\n\t\n\t\t// Check if element has sub-level nav\n\t\tfunction hasChildList(el) {\n\t\t\treturn !!getChildListEl(el);\n\t\t}\n\t\n\t\t// Get controlled element\n\t\tfunction getMegaDropdownEl(itemEl) {\n\t\t\tif (itemEl.hasAttribute('aria-controls')) {\n\t\t\t\treturn document.getElementById(itemEl.getAttribute('aria-controls'));\n\t\t\t}\n\t\t}\n\t\n\t\t// Check if element is a controller of another DOM element\n\t\tfunction isControlEl(el) {\n\t\t\treturn !!(getChildListEl(el) || getMegaDropdownEl(el));\n\t\t}\n\t\n\t\t// Check if element has been expanded\n\t\tfunction isExpanded(el) {\n\t\t\treturn el.getAttribute('aria-expanded') === 'true';\n\t\t}\n\t\n\t\t// Check if a certain element is inside the root nav\n\t\tfunction isElementInsideNav(el) {\n\t\t\tvar expandedLevel1El = rootEl.querySelector('[data-o-hierarchical-nav-level=\"1\"] > [aria-expanded=\"true\"]');\n\t\t\tvar expandedMegaDropdownEl = undefined;\n\t\t\tvar allLevel1Els = undefined;\n\t\n\t\t\tif (expandedLevel1El) {\n\t\t\t\texpandedMegaDropdownEl = getMegaDropdownEl(expandedLevel1El);\n\t\t\t\tif (expandedMegaDropdownEl && expandedMegaDropdownEl.contains(el)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tallLevel1Els = rootEl.querySelectorAll('[data-o-hierarchical-nav-level=\"1\"] > li');\n\t\n\t\t\tfor (var c = 0, l = allLevel1Els.length; c < l; c++) {\n\t\t\t\tif (allLevel1Els[c].contains(el)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Get the level a nav is in\n\t\tfunction getLevel(el) {\n\t\t\treturn parseInt(el.parentNode.getAttribute('data-o-hierarchical-nav-level'), 10);\n\t\t}\n\t\n\t\t// Check if a level 2 nav will fit in the window\n\t\tfunction level2ListFitsInWindow(l2El) {\n\t\t\treturn l2El.getBoundingClientRect().right < window.innerWidth;\n\t\t}\n\t\n\t\t// Check if an element will have enough space to its right\n\t\tfunction elementFitsToRight(el1, el2) {\n\t\t\treturn el1.getBoundingClientRect().right + el2.offsetWidth < window.innerWidth;\n\t\t}\n\t\n\t\t// Depending on if an element fits to its right or not, change its class to apply correct css\n\t\tfunction positionChildListEl(parentEl, childEl) {\n\t\t\tparentEl.classList.remove('o-hierarchical-nav--align-right');\n\t\t\tparentEl.classList.remove('o-hierarchical-nav__outside-right');\n\t\t\tparentEl.classList.remove('o-hierarchical-nav--left');\n\t\n\t\t\tif (!childEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (getLevel(parentEl) === 1) {\n\t\t\t\tif (!level2ListFitsInWindow(childEl)) {\n\t\t\t\t\tparentEl.classList.add('o-hierarchical-nav--align-right');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (elementFitsToRight(parentEl, childEl)) {\n\t\t\t\t\tparentEl.classList.add('o-hierarchical-nav__outside-right');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Hide an element\n\t\tfunction hideEl(el) {\n\t\t\tif (el) {\n\t\t\t\tel.setAttribute('aria-hidden', 'true');\n\t\t\t}\n\t\t}\n\t\n\t\t// Display an element\n\t\tfunction showEl(el) {\n\t\t\tif (el) {\n\t\t\t\tel.removeAttribute('aria-hidden');\n\t\t\t}\n\t\t}\n\t\n\t\t// Collapse all items from a certain node list\n\t\tfunction collapseAll(nodeList) {\n\t\t\tif (!nodeList) {\n\t\t\t\tnodeList = rootEl.querySelectorAll('[data-o-hierarchical-nav-level=\"1\"] > li[aria-expanded=true]');\n\t\t\t}\n\t\n\t\t\tutils.nodeListToArray(nodeList).forEach(function (childListItemEl) {\n\t\t\t\tif (isExpanded(childListItemEl)) {\n\t\t\t\t\tcollapseItem(childListItemEl);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\t// Set an element as not expanded, and if it has children, do the same to them\n\t\tfunction collapseItem(itemEl) {\n\t\t\titemEl.setAttribute('aria-expanded', 'false');\n\t\n\t\t\tif (utils.isIE8) {\n\t\t\t\titemEl.classList.add('forceIErepaint');\n\t\t\t\titemEl.classList.remove('forceIErepaint');\n\t\t\t}\n\t\n\t\t\tif (hasChildList(itemEl)) {\n\t\t\t\tcollapseAll(getChildListEl(itemEl).children);\n\t\t\t}\n\t\n\t\t\thideEl(getMegaDropdownEl(itemEl));\n\t\t\tdispatchCloseEvent(itemEl);\n\t\t}\n\t\n\t\t// Get same level items and collapse them\n\t\tfunction collapseSiblingItems(itemEl) {\n\t\t\tvar listLevel = oDom.getClosestMatch(itemEl, 'ul').getAttribute('data-o-hierarchical-nav-level');\n\t\t\tvar listItemEls = rootEl.querySelectorAll('[data-o-hierarchical-nav-level=\"' + listLevel + '\"] > li[aria-expanded=\"true\"]');\n\t\n\t\t\tfor (var c = 0, l = listItemEls.length; c < l; c++) {\n\t\t\t\tcollapseItem(listItemEls[c]);\n\t\t\t}\n\t\t}\n\t\n\t\t// Expand a nav item\n\t\tfunction expandItem(itemEl) {\n\t\t\tcollapseSiblingItems(itemEl);\n\t\t\titemEl.setAttribute('aria-expanded', 'true');\n\t\t\tpositionChildListEl(itemEl, getChildListEl(itemEl));\n\t\t\tshowEl(getMegaDropdownEl(itemEl));\n\t\t\tdispatchExpandEvent(itemEl);\n\t\t}\n\t\n\t\t// Helper method to dispatch o-layers new event\n\t\tfunction dispatchExpandEvent(itemEl) {\n\t\t\tutils.dispatchCustomEvent(itemEl, 'oLayers.new', { 'zIndex': 10, 'el': itemEl });\n\t\t}\n\t\n\t\t// Helper method to dispatch o-layers close event\n\t\tfunction dispatchCloseEvent(itemEl) {\n\t\t\tutils.dispatchCustomEvent(itemEl, 'oLayers.close', { 'zIndex': 10, 'el': itemEl });\n\t\t}\n\t\n\t\t// Handle clicks ourselved by expanding or collapsing selected element\n\t\tfunction handleClick(ev) {\n\t\t\tvar itemEl = oDom.getClosestMatch(ev.target, 'li');\n\t\n\t\t\tif (itemEl && isControlEl(itemEl)) {\n\t\t\t\tev.preventDefault();\n\t\n\t\t\t\tif (!isExpanded(itemEl)) {\n\t\t\t\t\texpandItem(itemEl);\n\t\t\t\t} else {\n\t\t\t\t\tcollapseItem(itemEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Position a level 3 nav and deeper\n\t\tfunction positionExpandedLevels() {\n\t\t\t// find deepest expanded menu element\n\t\t\tvar openMenus = rootEl.querySelectorAll('li[aria-expanded=\"true\"] > ul[data-o-hierarchical-nav-level]');\n\t\n\t\t\t// find the deepest level currently open\n\t\t\tvar deepestLevel = -1;\n\t\t\tfor (var c = 0, l = openMenus.length; c < l; c++) {\n\t\t\t\tdeepestLevel = Math.max(deepestLevel, openMenus[c].getAttribute(\"data-o-hierarchical-nav-level\"));\n\t\t\t}\n\t\n\t\t\t// start checking space / collapsing where needed\n\t\t\tfor (var l = 2; l <= deepestLevel; l++) {\n\t\t\t\tvar openLevelParentEl = rootEl.querySelector('[data-o-hierarchical-nav-level=\"' + l + '\"] > [aria-expanded=\"true\"]');\n\t\t\t\tvar openLevelChildEl = rootEl.querySelector('[data-o-hierarchical-nav-level=\"' + l + '\"] > [aria-expanded=\"true\"] > ul');\n\t\n\t\t\t\tif (openLevelParentEl && openLevelChildEl) {\n\t\t\t\t\tpositionChildListEl(openLevelParentEl, openLevelChildEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Position level 3 and below on resize\n\t\tfunction resize() {\n\t\t\tpositionExpandedLevels();\n\t\t}\n\t\n\t\t// Set all tabIndexes of a tags to 0\n\t\tfunction setTabIndexes() {\n\t\t\tvar aEls = rootEl.querySelectorAll('li > a');\n\t\n\t\t\tfor (var c = 0, l = aEls.length; c < l; c++) {\n\t\t\t\tif (!aEls[c].hasAttribute('href')) {\n\t\t\t\t\tif (aEls[c].tabIndex === 0) {\n\t\t\t\t\t\t// Don't override tabIndex if something else has set it, but otherwise set it to zero to make it focusable.\n\t\t\t\t\t\taEls[c].tabIndex = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction setLayersContext() {\n\t\t\t// We'll use the body as the default context\n\t\t\tbodyDelegate.on('oLayers.new', function (e) {\n\t\t\t\tif (!isElementInsideNav(e.detail.el)) {\n\t\t\t\t\tcollapseAll();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction init() {\n\t\t\tif (!rootEl) {\n\t\t\t\trootEl = document.body;\n\t\t\t} else if (!(rootEl instanceof HTMLElement)) {\n\t\t\t\trootEl = document.querySelector(rootEl);\n\t\t\t}\n\t\n\t\t\trootEl.setAttribute('data-o-hierarchical-nav--js', '');\n\t\t\tsetTabIndexes();\n\t\t\tsetLayersContext();\n\t\t\trootDelegate.on('click', handleClick);\n\t\t\trootDelegate.on('keyup', function (ev) {\n\t\t\t\t// Pressing enter key on anchors without @href won't trigger a click event\n\t\t\t\tif (!ev.target.hasAttribute('href') && ev.keyCode === 13 && isElementInsideNav(ev.target)) {\n\t\t\t\t\thandleClick(ev);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t// Collapse all elements if the user clicks outside the nav\n\t\t\tbodyDelegate.on('click', function (ev) {\n\t\t\t\tif (!isElementInsideNav(ev.target)) {\n\t\t\t\t\tcollapseAll();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction destroy() {\n\t\t\trootDelegate.destroy();\n\t\t\tbodyDelegate.destroy();\n\t\t\trootEl.removeAttribute('data-o-hierarchical-nav--js');\n\t\t}\n\t\n\t\tinit();\n\t\n\t\tthis.resize = resize;\n\t\tthis.collapseAll = collapseAll;\n\t\tthis.destroy = destroy;\n\t}\n\t\n\tmodule.exports = Nav;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(17);\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global exports*/\n\t\n\tfunction getClosestMatch(el, selector) {\n\t\twhile (el) {\n\t\t\tif (el.matches(selector)) {\n\t\t\t\treturn el;\n\t\t\t} else {\n\t\t\t\tel = el.parentElement;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tfunction getIndex(el) {\n\t\tvar i = 0;\n\t\tif (el && typeof el === 'object' && el.nodeType === 1) {\n\t\t\twhile (el.previousSibling) {\n\t\t\t\tel = el.previousSibling;\n\t\t\t\tif (el.nodeType === 1) {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t}\n\t\n\texports.getClosestMatch = getClosestMatch;\n\texports.getIndex = getIndex;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global exports*/\n\t\n\t// Helper function that converts a list of elements into an array\n\tfunction nodeListToArray(nl) {\n\t\treturn [].map.call(nl, function (element) {\n\t\t\treturn element;\n\t\t});\n\t}\n\t\n\t// Helper function to dispatch events\n\tfunction dispatchCustomEvent(el, name, data) {\n\t\tif (document.createEvent && el.dispatchEvent) {\n\t\t\tvar _event = document.createEvent('Event');\n\t\t\t_event.initEvent(name, true, true);\n\t\n\t\t\tif (data) {\n\t\t\t\t_event.detail = data;\n\t\t\t}\n\t\n\t\t\tel.dispatchEvent(_event);\n\t\t}\n\t}\n\t\n\tfunction isIE8() {\n\t\tvar b = document.createElement('B');\n\t\tvar docElem = document.documentElement;\n\t\tvar isIE = undefined;\n\t\n\t\tb.innerHTML = '<!--[if IE 8]><b id=\"ie8test\"></b><![endif]-->';\n\t\tdocElem.appendChild(b);\n\t\tisIE = !!document.getElementById('ie8test');\n\t\tdocElem.removeChild(b);\n\t\treturn isIE;\n\t}\n\t\n\texports.isIE8 = isIE8();\n\texports.nodeListToArray = nodeListToArray;\n\texports.dispatchCustomEvent = dispatchCustomEvent;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(20);\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require, module*/\n\t'use strict';\n\t\n\tvar oGallery = __webpack_require__(21);\n\tvar constructAll = function constructAll() {\n\t\toGallery.init();\n\t\tdocument.removeEventListener('o.DOMContentLoaded', constructAll);\n\t};\n\t\n\tdocument.addEventListener('o.DOMContentLoaded', constructAll);\n\t\n\tmodule.exports = oGallery;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require, module*/\n\t'use strict';\n\t\n\tvar oDom = __webpack_require__(16),\n\t    DomDelegate = __webpack_require__(8),\n\t    FTScroller = __webpack_require__(22).FTScroller,\n\t    oViewport = __webpack_require__(10),\n\t    galleryDom = __webpack_require__(23),\n\t    SimpleScroller = __webpack_require__(24);\n\t\n\tfunction Gallery(containerEl, config) {\n\t\n\t\tvar viewportEl;\n\t\tvar titleEl;\n\t\tvar allItemsEl;\n\t\tvar itemEls;\n\t\tvar selectedItemIndex;\n\t\tvar shownItemIndex;\n\t\tvar scroller;\n\t\tvar debounceScroll;\n\t\tvar prevControlDiv;\n\t\tvar nextControlDiv;\n\t\tvar propertyAttributeMap = {\n\t\t\tcomponent: \"data-o-component\",\n\t\t\tsyncID: \"data-o-gallery-syncid\",\n\t\t\tmultipleItemsPerPage: \"data-o-gallery-multipleitemsperpage\",\n\t\t\ttouch: \"data-o-gallery-touch\",\n\t\t\tcaptions: \"data-o-gallery-captions\",\n\t\t\tcaptionMinHeight: \"data-o-gallery-captionminheight\",\n\t\t\tcaptionMaxHeight: \"data-o-gallery-captionmaxheight\",\n\t\t\ttitle: \"data-o-gallery-title\"\n\t\t};\n\t\tvar defaultConfig = {\n\t\t\tcomponent: \"o-gallery\",\n\t\t\tmultipleItemsPerPage: false,\n\t\t\tcaptions: true,\n\t\t\tcaptionMinHeight: 24,\n\t\t\tcaptionMaxHeight: 52,\n\t\t\ttouch: false,\n\t\t\tsyncID: \"o-gallery-\" + new Date().getTime()\n\t\t};\n\t\tvar allowTransitions = false;\n\t\tvar bodyDomDelegate;\n\t\tvar containerDomDelegate;\n\t\n\t\tfunction supportsCssTransforms() {\n\t\t\tvar b = document.body || document.documentElement,\n\t\t\t    s = b.style,\n\t\t\t    p = 'Transition';\n\t\t\tvar v = ['', 'Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms'];\n\t\n\t\t\tfor (var i = 0; i < v.length; i++) {\n\t\t\t\tif (typeof s[v[i] + p] === 'string' || typeof s[v[i] + p.toLowerCase()] === 'string') return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfunction isDataSource() {\n\t\t\treturn config.items && config.items.length > 0;\n\t\t}\n\t\n\t\tfunction setWidths() {\n\t\t\tvar totalWidth = 0;\n\t\t\tvar itemWidth;\n\t\n\t\t\tif (config.multipleItemsPerPage) {\n\t\t\t\titemWidth = parseInt(itemEls[selectedItemIndex].clientWidth, 10);\n\t\t\t} else {\n\t\t\t\titemWidth = containerEl.clientWidth;\n\t\t\t}\n\t\t\tfor (var i = 0; i < itemEls.length; i++) {\n\t\t\t\titemEls[i].style.width = itemWidth + \"px\";\n\t\t\t\ttotalWidth += itemWidth;\n\t\t\t}\n\t\t\tallItemsEl.style.width = totalWidth + \"px\";\n\t\t\t// Makes sure Scroller know about the width change\n\t\t\tscroller.updateDimensions();\n\t\t}\n\t\n\t\tfunction isValidItem(n) {\n\t\t\treturn typeof n === \"number\" && n > -1 && n < itemEls.length;\n\t\t}\n\t\n\t\tfunction getSelectedItem() {\n\t\t\tvar selectedItem = 0;\n\t\t\tfor (var i = 0; i < itemEls.length; i++) {\n\t\t\t\tif (itemEls[i].getAttribute('aria-selected') === 'true') {\n\t\t\t\t\tselectedItem = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn selectedItem;\n\t\t}\n\t\n\t\tfunction selectOnClick(evt) {\n\t\t\tvar clickedItemNum = oDom.getIndex(oDom.getClosestMatch(evt.srcElement, \".o-gallery__item\"));\n\t\t\tselectItem(clickedItemNum, true, \"user\");\n\t\t}\n\t\n\t\tfunction addUiControls() {\n\t\t\tprevControlDiv = galleryDom.createElement(\"div\", \"\", \"o-gallery__control o-gallery__control--prev\");\n\t\t\tnextControlDiv = galleryDom.createElement(\"div\", \"\", \"o-gallery__control o-gallery__control--next\");\n\t\t\tcontainerEl.appendChild(prevControlDiv);\n\t\t\tcontainerEl.appendChild(nextControlDiv);\n\t\t\tcontainerDomDelegate.on('click', '.o-gallery__control--prev', prev);\n\t\t\tcontainerDomDelegate.on('click', '.o-gallery__control--next', next);\n\t\t\tif (config.multipleItemsPerPage) {\n\t\t\t\tcontainerDomDelegate.on('click', '.o-gallery__viewport', selectOnClick);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction updateControlStates() {\n\t\t\tprevControlDiv.setAttribute('aria-hidden', String(scroller.scrollLeft <= 0));\n\t\t\tnextControlDiv.setAttribute('aria-hidden', String(scroller.scrollLeft >= allItemsEl.clientWidth - viewportEl.clientWidth));\n\t\t}\n\t\n\t\tfunction getTitleEl() {\n\t\t\ttitleEl = containerEl.querySelector(\".o-gallery__title\");\n\t\t\tif (config.title) {\n\t\t\t\tif (titleEl) {\n\t\t\t\t\ttitleEl.innerHTML = config.title;\n\t\t\t\t} else {\n\t\t\t\t\ttitleEl = galleryDom.createElement('div', config.title, 'o-gallery__title');\n\t\t\t\t\tcontainerEl.appendChild(titleEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction setCaptionSizes() {\n\t\t\tfor (var i = 0; i < itemEls.length; i++) {\n\t\t\t\tvar itemEl = itemEls[i];\n\t\t\t\titemEl.style.paddingBottom = config.captionMinHeight + \"px\";\n\t\t\t\tvar captionEl = itemEl.querySelector(\".o-gallery__item__caption\");\n\t\t\t\tif (captionEl) {\n\t\t\t\t\tcaptionEl.style.minHeight = config.captionMinHeight + \"px\";\n\t\t\t\t\tcaptionEl.style.maxHeight = config.captionMaxHeight + \"px\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction insertItemContent(n) {\n\t\t\tvar itemNums = n instanceof Array ? n : [n];\n\t\t\tif (config.items) {\n\t\t\t\tfor (var i = 0; i < itemNums.length; i++) {\n\t\t\t\t\tvar itemNum = itemNums[i];\n\t\t\t\t\tif (isValidItem(itemNum) && !config.items[itemNum].inserted) {\n\t\t\t\t\t\tgalleryDom.insertItemContent(config, config.items[itemNum], itemEls[itemNum]);\n\t\t\t\t\t\tconfig.items[itemNum].inserted = true;\n\t\t\t\t\t\tsetCaptionSizes();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction isWholeItemInPageView(itemNum, l, r) {\n\t\t\treturn itemEls[itemNum].offsetLeft >= l && itemEls[itemNum].offsetLeft + itemEls[itemNum].clientWidth <= r;\n\t\t}\n\t\n\t\tfunction isAnyPartOfItemInPageView(itemNum, l, r) {\n\t\t\treturn itemEls[itemNum].offsetLeft >= l - itemEls[itemNum].clientWidth && itemEls[itemNum].offsetLeft <= r;\n\t\t}\n\t\n\t\tfunction getItemsInPageView(l, r, whole) {\n\t\t\tvar itemsInView = [];\n\t\t\tvar onlyWhole = typeof whole !== \"boolean\" ? true : whole;\n\t\t\tfor (var i = 0; i < itemEls.length; i++) {\n\t\t\t\tif (onlyWhole && isWholeItemInPageView(i, l, r) || !onlyWhole && isAnyPartOfItemInPageView(i, l, r)) {\n\t\t\t\t\titemsInView.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn itemsInView;\n\t\t}\n\t\n\t\tfunction onGalleryCustomEvent(evt) {\n\t\t\tif (evt.srcElement !== containerEl && evt.detail.syncID === config.syncID && evt.detail.source === \"user\") {\n\t\t\t\tselectItem(evt.detail.itemID, true);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction listenForSyncEvents() {\n\t\t\tbodyDomDelegate.on('oGallery.itemSelect', onGalleryCustomEvent);\n\t\t}\n\t\n\t\tfunction triggerEvent(name, data) {\n\t\t\tdata.syncID = config.syncID;\n\t\t\tvar event = new CustomEvent(name, {\n\t\t\t\t'bubbles': true,\n\t\t\t\t'cancelable': true,\n\t\t\t\t'detail': data || {}\n\t\t\t});\n\t\t\tcontainerEl.dispatchEvent(event);\n\t\t}\n\t\n\t\tfunction moveViewport(left) {\n\t\t\tscroller.scrollTo(left, 0, allowTransitions ? true : 0);\n\t\t\tinsertItemContent(getItemsInPageView(left, left + viewportEl.clientWidth, false));\n\t\t}\n\t\n\t\tfunction alignItemLeft(n) {\n\t\t\tmoveViewport(itemEls[n].offsetLeft);\n\t\t}\n\t\n\t\tfunction alignItemRight(n) {\n\t\t\tvar newScrollLeft = itemEls[n].offsetLeft - (viewportEl.clientWidth - itemEls[n].clientWidth);\n\t\t\tmoveViewport(newScrollLeft);\n\t\t}\n\t\n\t\tfunction bringItemIntoView(n) {\n\t\t\tif (!isValidItem(n)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar viewportL = scroller.scrollLeft;\n\t\t\tvar viewportR = viewportL + viewportEl.clientWidth;\n\t\t\tvar itemL = itemEls[n].offsetLeft;\n\t\t\tvar itemR = itemL + itemEls[n].clientWidth;\n\t\t\tif (itemL > viewportL && itemR < viewportR) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (itemL < viewportL) {\n\t\t\t\talignItemLeft(n);\n\t\t\t} else if (itemR > viewportR) {\n\t\t\t\talignItemRight(n);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction showItem(n) {\n\t\t\tif (isValidItem(n)) {\n\t\t\t\tbringItemIntoView(n);\n\t\t\t\tshownItemIndex = n;\n\t\t\t\tupdateControlStates();\n\t\t\t}\n\t\t}\n\t\n\t\tfunction showPrevItem() {\n\t\t\tvar prev = shownItemIndex - 1 >= 0 ? shownItemIndex - 1 : itemEls.length - 1;\n\t\t\tshowItem(prev);\n\t\t}\n\t\n\t\tfunction showNextItem() {\n\t\t\tvar next = shownItemIndex + 1 < itemEls.length ? shownItemIndex + 1 : 0;\n\t\t\tshowItem(next);\n\t\t}\n\t\n\t\tfunction showPrevPage() {\n\t\t\tif (scroller.scrollLeft > 0) {\n\t\t\t\tvar prevPageWholeItems = getItemsInPageView(scroller.scrollLeft - viewportEl.clientWidth, scroller.scrollLeft);\n\t\t\t\tvar prevPageItem = prevPageWholeItems.pop() || 0;\n\t\t\t\talignItemRight(prevPageItem);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction showNextPage() {\n\t\t\tif (scroller.scrollLeft < allItemsEl.clientWidth - viewportEl.clientWidth) {\n\t\t\t\tvar currentWholeItemsInView = getItemsInPageView(scroller.scrollLeft, scroller.scrollLeft + viewportEl.clientWidth);\n\t\t\t\tvar lastWholeItemInView = currentWholeItemsInView.pop();\n\t\t\t\talignItemLeft(lastWholeItemInView + 1);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction selectItem(n, show, source) {\n\t\t\tif (!source) {\n\t\t\t\tsource = \"api\";\n\t\t\t}\n\t\t\tif (isValidItem(n)) {\n\t\t\t\tif (show) {\n\t\t\t\t\tshowItem(n);\n\t\t\t\t}\n\t\t\t\tif (n !== selectedItemIndex) {\n\t\t\t\t\titemEls[selectedItemIndex].setAttribute('aria-selected', 'false');\n\t\t\t\t\tselectedItemIndex = n;\n\t\t\t\t\titemEls[selectedItemIndex].setAttribute('aria-selected', 'true');\n\t\t\t\t\ttriggerEvent(\"oGallery.itemSelect\", {\n\t\t\t\t\t\titemID: selectedItemIndex,\n\t\t\t\t\t\tsource: source\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction selectPrevItem(show, source) {\n\t\t\tvar prev = selectedItemIndex - 1 >= 0 ? selectedItemIndex - 1 : itemEls.length - 1;\n\t\t\tselectItem(prev, show, source);\n\t\t}\n\t\n\t\tfunction selectNextItem(show, source) {\n\t\t\tvar next = selectedItemIndex + 1 < itemEls.length ? selectedItemIndex + 1 : 0;\n\t\t\tselectItem(next, show, source);\n\t\t}\n\t\n\t\tfunction prev() {\n\t\t\tif (config.multipleItemsPerPage) {\n\t\t\t\tshowPrevPage();\n\t\t\t} else {\n\t\t\t\tselectPrevItem(true, \"user\");\n\t\t\t}\n\t\t}\n\t\n\t\tfunction next() {\n\t\t\tif (config.multipleItemsPerPage) {\n\t\t\t\tshowNextPage();\n\t\t\t} else {\n\t\t\t\tselectNextItem(true, \"user\");\n\t\t\t}\n\t\t}\n\t\n\t\tfunction onResize() {\n\t\t\tsetWidths();\n\t\t\tif (!config.multipleItemsPerPage) {\n\t\t\t\t// correct the alignment of item in view\n\t\t\t\tshowItem(shownItemIndex);\n\t\t\t} else {\n\t\t\t\tvar newScrollLeft = scroller.scrollLeft;\n\t\t\t\tinsertItemContent(getItemsInPageView(newScrollLeft, newScrollLeft + viewportEl.clientWidth, false));\n\t\t\t}\n\t\t}\n\t\n\t\tfunction extendObjects(objs) {\n\t\t\tvar newObj = {};\n\t\t\tfor (var i = 0; i < objs.length; i++) {\n\t\t\t\tvar obj = objs[i];\n\t\t\t\tfor (var prop in obj) {\n\t\t\t\t\tif (obj.hasOwnProperty(prop)) {\n\t\t\t\t\t\tnewObj[prop] = obj[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newObj;\n\t\t}\n\t\n\t\tfunction updateDataAttributes() {\n\t\t\tgalleryDom.setAttributesFromProperties(containerEl, config, propertyAttributeMap, [\"items\"]);\n\t\t}\n\t\n\t\tfunction getSyncID() {\n\t\t\treturn config.syncID;\n\t\t}\n\t\n\t\tfunction syncWith(galleryInstance) {\n\t\t\tconfig.syncID = galleryInstance.getSyncID();\n\t\t\tupdateDataAttributes();\n\t\t}\n\t\n\t\tfunction onScroll(evt) {\n\t\t\tupdateControlStates();\n\t\t\tinsertItemContent(getItemsInPageView(evt.scrollLeft, evt.scrollLeft + viewportEl.clientWidth, false));\n\t\t}\n\t\n\t\tfunction destroy() {\n\t\t\t// Destroy objects before manipulating the dom. Order is important for gallery to be destroyed properly\n\t\t\t// It won't instantiate again nicely if it's the other way round\n\t\t\tcontainerDomDelegate.destroy();\n\t\t\tbodyDomDelegate.destroy();\n\t\t\twindow.removeEventListener(\"oViewport.resize\", onResize, false);\n\t\t\tclearTimeout(debounceScroll);\n\t\t\tscroller.destroy(true);\n\t\t\tprevControlDiv.parentNode.removeChild(prevControlDiv);\n\t\t\tprevControlDiv = null;\n\t\t\tnextControlDiv.parentNode.removeChild(nextControlDiv);\n\t\t\tnextControlDiv = null;\n\t\t\tfor (var prop in propertyAttributeMap) {\n\t\t\t\tif (propertyAttributeMap.hasOwnProperty(prop)) {\n\t\t\t\t\tcontainerEl.removeAttribute(propertyAttributeMap[prop]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontainerEl.removeAttribute('data-o-gallery--js');\n\t\t}\n\t\n\t\tif (!containerEl) {\n\t\t\tcontainerEl = document.body;\n\t\t} else if (containerEl.nodeType !== 1) {\n\t\t\tcontainerEl = document.querySelector(containerEl);\n\t\t}\n\t\n\t\tcontainerEl.setAttribute('data-o-gallery--js', '');\n\t\tbodyDomDelegate = new DomDelegate(document.body);\n\t\tcontainerDomDelegate = new DomDelegate(containerEl);\n\t\tif (isDataSource()) {\n\t\t\tgalleryDom.emptyElement(containerEl);\n\t\t\tcontainerEl.classList.add(\"o-gallery\");\n\t\t\tallItemsEl = galleryDom.createItemsList(containerEl);\n\t\t\titemEls = galleryDom.createItems(allItemsEl, config.items);\n\t\t}\n\t\tconfig = extendObjects([defaultConfig, galleryDom.getPropertiesFromAttributes(containerEl, propertyAttributeMap), config]);\n\t\tupdateDataAttributes();\n\t\tgetTitleEl();\n\t\tallItemsEl = allItemsEl || containerEl.querySelector(\".o-gallery__items\");\n\t\titemEls = itemEls || containerEl.querySelectorAll(\".o-gallery__item\");\n\t\tselectedItemIndex = getSelectedItem();\n\t\tshownItemIndex = selectedItemIndex;\n\t\n\t\t// Generate an array of item indexes\n\t\tinsertItemContent(Object.keys(itemEls));\n\t\tsetCaptionSizes();\n\t\tif (supportsCssTransforms()) {\n\t\t\tscroller = new FTScroller(containerEl, {\n\t\t\t\tscrollbars: false,\n\t\t\t\tscrollingY: false,\n\t\t\t\tupdateOnWindowResize: true,\n\t\t\t\tsnapping: !config.multipleItemsPerPage,\n\t\t\t\t/* Can't use fling/inertial scroll as after user input is finished and scroll continues, scroll events are no\n\t    longer fired, and value of scrollLeft doesn't change until scrollend. */\n\t\t\t\tflinging: false,\n\t\t\t\tdisabledInputMethods: {\n\t\t\t\t\ttouch: !config.touch,\n\t\t\t\t\tscroll: true\n\t\t\t\t}\n\t\t\t});\n\t\t\tscroller.addEventListener(\"scroll\", function (evt) {\n\t\t\t\tclearTimeout(debounceScroll);\n\t\t\t\tdebounceScroll = setTimeout(function () {\n\t\t\t\t\tonScroll(evt);\n\t\t\t\t}, 50);\n\t\t\t});\n\t\t\tscroller.addEventListener(\"scrollend\", function (evt) {\n\t\t\t\tonScroll(evt);\n\t\t\t\ttriggerEvent('oGallery.scrollEnd', evt);\n\t\t\t});\n\t\t\tscroller.addEventListener(\"segmentwillchange\", function () {\n\t\t\t\tif (!config.multipleItemsPerPage) {\n\t\t\t\t\tselectItem(scroller.currentSegment.x, false, \"user\");\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tscroller = new SimpleScroller(containerEl);\n\t\t\tcontainerEl.addEventListener(\"scrollend\", function (evt) {\n\t\t\t\tonScroll(evt);\n\t\t\t\ttriggerEvent('oGallery.scrollEnd', evt);\n\t\t\t});\n\t\t}\n\t\tviewportEl = scroller.contentContainerNode.parentNode;\n\t\tviewportEl.classList.add(\"o-gallery__viewport\");\n\t\tif (titleEl && supportsCssTransforms()) {\n\t\t\t// Title needs to be moved into the viewport so it stays visible when pages change\n\t\t\ttitleEl.parentNode.removeChild(titleEl);\n\t\t\tviewportEl.appendChild(titleEl);\n\t\t}\n\t\taddUiControls();\n\t\tshowItem(selectedItemIndex);\n\t\tif (config.multipleItemsPerPage === true) {\n\t\t\tallowTransitions = true;\n\t\t}\n\t\tupdateControlStates();\n\t\tlistenForSyncEvents();\n\t\n\t\t// If it's the thumbnails gallery, check that the thumbnails' clientwidth has been set before resizing\n\t\t// as this takes time in IE8\n\t\tvar resizeLimit = 50;\n\t\tfunction forceResize() {\n\t\t\tif (!config.multipleItemsPerPage || parseInt(itemEls[selectedItemIndex].clientWidth, 10) !== 0) {\n\t\t\t\tonResize();\n\t\t\t} else if (resizeLimit > 0) {\n\t\t\t\tsetTimeout(forceResize, 150);\n\t\t\t\tresizeLimit--;\n\t\t\t}\n\t\t}\n\t\toViewport.listenTo('resize');\n\t\twindow.addEventListener(\"oViewport.resize\", onResize, false);\n\t\t// Force an initial resize in case all images are loaded before o.DOMContentLoaded is fired and the resize event hasn't\n\t\tforceResize();\n\t\n\t\tthis.showItem = showItem;\n\t\tthis.getSelectedItem = getSelectedItem;\n\t\tthis.showPrevItem = showPrevItem;\n\t\tthis.showNextItem = showNextItem;\n\t\tthis.showPrevPage = showPrevPage;\n\t\tthis.showNextPage = showNextPage;\n\t\tthis.selectItem = selectItem;\n\t\tthis.selectPrevItem = selectPrevItem;\n\t\tthis.selectNextItem = selectNextItem;\n\t\tthis.next = next;\n\t\tthis.prev = prev;\n\t\tthis.getSyncID = getSyncID;\n\t\tthis.syncWith = syncWith;\n\t\tthis.onResize = onResize;\n\t\tthis.getGalleryElement = function () {\n\t\t\treturn containerEl;\n\t\t};\n\t\tthis.destroy = destroy;\n\t\n\t\ttriggerEvent(\"oGallery.ready\", {\n\t\t\tgallery: this\n\t\t});\n\t}\n\t\n\tGallery.init = function (el, config) {\n\t\tvar conf = config || {};\n\t\tvar gEls;\n\t\tvar galleries = [];\n\t\tif (!el) {\n\t\t\tel = document.body;\n\t\t} else if (el.nodeType !== 1) {\n\t\t\tel = document.querySelector(el);\n\t\t}\n\t\tif (el.querySelectorAll) {\n\t\t\tgEls = el.querySelectorAll(\"[data-o-component~=o-gallery]\");\n\t\t\tfor (var i = 0; i < gEls.length; i++) {\n\t\t\t\tif (!gEls[i].hasAttribute('data-o-gallery--js')) {\n\t\t\t\t\tgalleries.push(new Gallery(gEls[i], conf));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn galleries;\n\t};\n\t\n\tmodule.exports = Gallery;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/'use strict';var define=false; /**\n\t * FTScroller: touch and mouse-based scrolling for DOM elements larger than their containers.\n\t *\n\t * While this is a rewrite, it is heavily inspired by two projects:\n\t * 1) Uxebu TouchScroll (https://github.com/davidaurelio/TouchScroll), BSD licensed:\n\t *    Copyright (c) 2010 uxebu Consulting Ltd. & Co. KG\n\t *    Copyright (c) 2010 David Aurelio\n\t * 2) Zynga Scroller (https://github.com/zynga/scroller), MIT licensed:\n\t *    Copyright 2011, Zynga Inc.\n\t *    Copyright 2011, Deutsche Telekom AG\n\t *\n\t * Includes CubicBezier:\n\t *\n\t * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n\t * Copyright (C) 2010 David Aurelio. All Rights Reserved.\n\t * Copyright (C) 2010 uxebu Consulting Ltd. & Co. KG. All Rights Reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions\n\t * are met:\n\t * 1. Redistributions of source code must retain the above copyright\n\t *    notice, this list of conditions and the following disclaimer.\n\t * 2. Redistributions in binary form must reproduce the above copyright\n\t *    notice, this list of conditions and the following disclaimer in the\n\t *    documentation and/or other materials provided with the distribution.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY APPLE INC., DAVID AURELIO, AND UXEBU\n\t * CONSULTING LTD. & CO. KG ``AS IS'' AND ANY EXPRESS OR IMPLIED\n\t * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n\t * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n\t * IN NO EVENT SHALL APPLE INC. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n\t * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n\t * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n\t * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\t * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n\t * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n\t * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\t * POSSIBILITY OF SUCH DAMAGE.\n\t *\n\t * @copyright The Financial Times Ltd [All rights reserved]\n\t * @codingstandard ftlabs-jslint\n\t * @version 0.6.2\n\t */ /**\n\t * @license FTScroller is (c) 2012 The Financial Times Ltd [All rights reserved] and licensed under the MIT license.\n\t *\n\t * Inspired by Uxebu TouchScroll, (c) 2010 uxebu Consulting Ltd. & Co. KG and David Aurelio, which is BSD licensed (https://github.com/davidaurelio/TouchScroll)\n\t * Inspired by Zynga Scroller, (c) 2011 Zynga Inc and Deutsche Telekom AG, which is MIT licensed (https://github.com/zynga/scroller)\n\t * Includes CubicBezier, (c) 2008 Apple Inc [All rights reserved], (c) 2010 David Aurelio and uxebu Consulting Ltd. & Co. KG. [All rights reserved], which is 2-clause BSD licensed (see above or https://github.com/davidaurelio/TouchScroll).\n\t */ /*jslint nomen: true, vars: true, browser: true, continue: true, white: true*/ /*globals FTScrollerOptions*/var FTScroller,CubicBezier;(function(){'use strict'; // Determine the browser engine and prefix, trying to use the unprefixed version where available.\n\tvar _vendorCSSPrefix,_vendorStylePropertyPrefix,_vendorTransformLookup,_pointerEventsPrefixed,_setPointerCapture,_releasePointerCapture,_lostPointerCapture,_trackPointerEvents,_pointerTypeTouch;if(document.createElement('div').style.transform !== undefined){_vendorCSSPrefix = '';_vendorStylePropertyPrefix = '';_vendorTransformLookup = 'transform';}else if(window.opera && Object.prototype.toString.call(window.opera) === '[object Opera]'){_vendorCSSPrefix = '-o-';_vendorStylePropertyPrefix = 'O';_vendorTransformLookup = 'OTransform';}else if(document.documentElement.style.MozTransform !== undefined){_vendorCSSPrefix = '-moz-';_vendorStylePropertyPrefix = 'Moz';_vendorTransformLookup = 'MozTransform';}else if(document.documentElement.style.webkitTransform !== undefined){_vendorCSSPrefix = '-webkit-';_vendorStylePropertyPrefix = 'webkit';_vendorTransformLookup = '-webkit-transform';}else if(typeof navigator.cpuClass === 'string'){_vendorCSSPrefix = '-ms-';_vendorStylePropertyPrefix = 'ms';_vendorTransformLookup = '-ms-transform';} // Pointer Events are unprefixed in IE11\n\tif('pointerEnabled' in window.navigator){_pointerEventsPrefixed = false;_trackPointerEvents = window.navigator.pointerEnabled;_setPointerCapture = 'setPointerCapture';_releasePointerCapture = 'releasePointerCapture';_lostPointerCapture = 'lostpointercapture';_pointerTypeTouch = 'touch';}else if('msPointerEnabled' in window.navigator){_pointerEventsPrefixed = true;_trackPointerEvents = window.navigator.msPointerEnabled;_setPointerCapture = 'msSetPointerCapture';_releasePointerCapture = 'msReleasePointerCapture';_lostPointerCapture = 'MSLostPointerCapture';_pointerTypeTouch = 2; // PointerEvent.MSPOINTER_TYPE_TOUCH = 2 in IE10\n\t} // Global flag to determine if any scroll is currently active.  This prevents\n\t// issues when using multiple scrollers, particularly when they're nested.\n\tvar _ftscrollerMoving=false; // Determine whether pointer events or touch events can be used\n\tvar _trackTouchEvents=!_trackPointerEvents; // Determine whether to use modern hardware acceleration rules or dynamic/toggleable rules.\n\t// Certain older browsers - particularly Android browsers - have problems with hardware\n\t// acceleration, so being able to toggle the behaviour dynamically via a CSS cascade is desirable.\n\tvar _useToggleableHardwareAcceleration=false;if('hasOwnProperty' in window){_useToggleableHardwareAcceleration = !window.hasOwnProperty('ArrayBuffer');} // Feature detection\n\tvar _canClearSelection=window.Selection && window.Selection.prototype.removeAllRanges; // If hardware acceleration is using the standard path, but perspective doesn't seem to be supported,\n\t// 3D transforms likely aren't supported either\n\tif(!_useToggleableHardwareAcceleration && document.createElement('div').style[_vendorStylePropertyPrefix + (_vendorStylePropertyPrefix?'P':'p') + 'erspective'] === undefined){_useToggleableHardwareAcceleration = true;} // Style prefixes\n\tvar _transformProperty=_vendorStylePropertyPrefix + (_vendorStylePropertyPrefix?'T':'t') + 'ransform';var _transitionProperty=_vendorStylePropertyPrefix + (_vendorStylePropertyPrefix?'T':'t') + 'ransition';var _translateRulePrefix=_useToggleableHardwareAcceleration?'translate(':'translate3d(';var _transformPrefixes={x:'',y:'0,'};var _transformSuffixes={x:',0' + (_useToggleableHardwareAcceleration?')':',0)'),y:_useToggleableHardwareAcceleration?')':',0)'}; // Constants.  Note that the bezier curve should be changed along with the friction!\n\tvar _kFriction=0.998;var _kMinimumSpeed=0.01; // Create a global stylesheet to set up stylesheet rules and track dynamic entries\n\t(function(){var stylesheetContainerNode=document.getElementsByTagName('head')[0] || document.documentElement;var newStyleNode=document.createElement('style');var hardwareAccelerationRule;var _styleText;newStyleNode.type = 'text/css'; // Determine the hardware acceleration logic to use\n\tif(_useToggleableHardwareAcceleration){hardwareAccelerationRule = _vendorCSSPrefix + 'transform-style: preserve-3d;';}else {hardwareAccelerationRule = _vendorCSSPrefix + 'transform: translateZ(0);';} // Add our rules\n\t_styleText = ['.ftscroller_container { overflow: hidden; position: relative; max-height: 100%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -ms-touch-action: none }','.ftscroller_hwaccelerated { ' + hardwareAccelerationRule + ' }','.ftscroller_x, .ftscroller_y { position: relative; min-width: 100%; min-height: 100%; overflow: hidden }','.ftscroller_x { display: inline-block }','.ftscroller_scrollbar { pointer-events: none; position: absolute; width: 5px; height: 5px; border: 1px solid rgba(255, 255, 255, 0.3); -webkit-border-radius: 3px; border-radius: 6px; opacity: 0; ' + _vendorCSSPrefix + 'transition: opacity 350ms; z-index: 10; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box }','.ftscroller_scrollbarx { bottom: 2px; left: 2px }','.ftscroller_scrollbary { right: 2px; top: 2px }','.ftscroller_scrollbarinner { height: 100%; background: #000; -webkit-border-radius: 2px; border-radius: 4px / 6px }','.ftscroller_scrollbar.active { opacity: 0.5; ' + _vendorCSSPrefix + 'transition: none; -o-transition: all 0 none }'];if(newStyleNode.styleSheet){newStyleNode.styleSheet.cssText = _styleText.join('\\n');}else {newStyleNode.appendChild(document.createTextNode(_styleText.join('\\n')));} // Add the stylesheet\n\tstylesheetContainerNode.insertBefore(newStyleNode,stylesheetContainerNode.firstChild);})(); /**\n\t\t * Master constructor for the scrolling function, including which element to\n\t\t * construct the scroller in, and any scrolling options.\n\t\t * Note that app-wide options can also be set using a global FTScrollerOptions\n\t\t * object.\n\t\t */FTScroller = function(domNode,options){var key;var destroy,setSnapSize,scrollTo,scrollBy,updateDimensions,addEventListener,removeEventListener,setDisabledInputMethods,_startScroll,_updateScroll,_endScroll,_finalizeScroll,_interruptScroll,_flingScroll,_snapScroll,_getSnapPositionForIndexes,_getSnapIndexForPosition,_constrainAndRenderTargetScrollPosition,_limitToBounds,_initializeDOM,_existingDOMValid,_domChanged,_updateDimensions,_updateScrollbarDimensions,_updateElementPosition,_updateSegments,_setAxisPosition,_getPosition,_scheduleAxisPosition,_fireEvent,_childFocused,_modifyDistanceBeyondBounds,_distancesBeyondBounds,_startAnimation,_scheduleRender,_cancelAnimation,_addEventHandlers,_removeEventHandlers,_resetEventHandlers,_onTouchStart,_onTouchMove,_onTouchEnd,_onMouseDown,_onMouseMove,_onMouseUp,_onPointerDown,_onPointerMove,_onPointerUp,_onPointerCancel,_onPointerCaptureEnd,_onClick,_onMouseScroll,_captureInput,_releaseInputCapture,_getBoundingRect; /* Note that actual object instantiation occurs at the end of the closure to avoid jslint errors */ /*                         Options                       */var _instanceOptions={ // Whether to display scrollbars as appropriate\n\tscrollbars:true, // Enable scrolling on the X axis if content is available\n\tscrollingX:true, // Enable scrolling on the Y axis if content is available\n\tscrollingY:true, // The initial movement required to trigger a scroll, in pixels; this is the point at which\n\t// the scroll is exclusive to this particular FTScroller instance.\n\tscrollBoundary:1, // The initial movement required to trigger a visual indication that scrolling is occurring,\n\t// in pixels.  This is enforced to be less than or equal to the scrollBoundary, and is used to\n\t// define when the scroller starts drawing changes in response to an input, even if the scroll\n\t// is not treated as having begun/locked yet.\n\tscrollResponseBoundary:1, // Whether to always enable scrolling, even if the content of the scroller does not\n\t// require the scroller to function.  This makes the scroller behave more like an\n\t// element set to \"overflow: scroll\", with bouncing always occurring if enabled.\n\talwaysScroll:false, // The content width to use when determining scroller dimensions.  If this\n\t// is false, the width will be detected based on the actual content.\n\tcontentWidth:undefined, // The content height to use when determining scroller dimensions.  If this\n\t// is false, the height will be detected based on the actual content.\n\tcontentHeight:undefined, // Enable snapping of content to 'pages' or a pixel grid\n\tsnapping:false, // Define the horizontal interval of the pixel grid; snapping must be enabled for this to\n\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\tsnapSizeX:undefined, // Define the vertical interval of the pixel grid; snapping must be enabled for this to\n\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\tsnapSizeY:undefined, // Control whether snapping should be curtailed to only ever flick to the next page\n\t// and not beyond.  Snapping needs to be enabled for this to take effect.\n\tsinglePageScrolls:false, // Allow scroll bouncing and elasticity near the ends and grid\n\tbouncing:true, // Allow a fast scroll to continue with momentum when released\n\tflinging:true, // Automatically detects changes to the contained markup and\n\t// updates its dimensions whenever the content changes. This is\n\t// set to false if a contentWidth or contentHeight are supplied.\n\tupdateOnChanges:true, // Automatically catches changes to the window size and updates\n\t// its dimensions.\n\tupdateOnWindowResize:false, // The alignment to use if the content is smaller than the container;\n\t// this also applies to initial positioning of scrollable content.\n\t// Valid alignments are -1 (top or left), 0 (center), and 1 (bottom or right).\n\tbaseAlignments:{x:-1,y:-1}, // Whether to use a window scroll flag, eg window.foo, to control whether\n\t// to allow scrolling to start or now.  If the window flag is set to true,\n\t// this element will not start scrolling; this element will also toggle\n\t// the variable while scrolling\n\twindowScrollingActiveFlag:undefined, // Instead of always using translate3d for transforms, a mix of translate3d\n\t// and translate with a hardware acceleration class used to trigger acceleration\n\t// is used; this is to allow CSS inheritance to be used to allow dynamic\n\t// disabling of backing layers on older platforms.\n\thwAccelerationClass:'ftscroller_hwaccelerated', // While use of requestAnimationFrame is highly recommended on platforms\n\t// which support it, it can result in the animation being a further half-frame\n\t// behind the input method, increasing perceived lag slightly.  To disable this,\n\t// set this property to false.\n\tenableRequestAnimationFrameSupport:true, // Set the maximum time (ms) that a fling can take to complete; if\n\t// this is not set, flings will complete instantly\n\tmaxFlingDuration:1000, // Whether to disable any input methods; on some multi-input devices\n\t// custom behaviour may be desired for some scrollers.  Use with care!\n\tdisabledInputMethods:{mouse:false,touch:false,scroll:false,pointer:false,focus:false}, // Define a scrolling class to be added to the scroller container\n\t// when scrolling is active.  Note that this can cause a relayout on\n\t// scroll start if defined, but allows custom styling in response to scrolls\n\tscrollingClassName:undefined, // Bezier curves defining the feel of the fling (momentum) deceleration,\n\t// the bounce decleration deceleration (as a fling exceeds the bounds),\n\t// and the bounce bezier (used for bouncing back).\n\tflingBezier:new CubicBezier(0.103,0.389,0.307,0.966),bounceDecelerationBezier:new CubicBezier(0,0.5,0.5,1),bounceBezier:new CubicBezier(0.7,0,0.9,0.6), // If the scroller is constrained to an x axis, convert y scroll to allow single-axis scroll\n\t// wheels to scroll constrained content.\n\tinvertScrollWheel:true}; /*                     Local variables                   */ // Cache the DOM node and set up variables for other nodes\n\tvar _publicSelf;var _self=this;var _scrollableMasterNode=domNode;var _containerNode;var _contentParentNode;var _scrollNodes={x:null,y:null};var _scrollbarNodes={x:null,y:null}; // Dimensions of the container element and the content element\n\tvar _metrics={container:{x:null,y:null},content:{x:null,y:null,rawX:null,rawY:null},scrollEnd:{x:null,y:null}}; // Snapping details\n\tvar _snapGridSize={x:false,y:false,userX:false,userY:false};var _snapIndex={x:0,y:0};var _baseSegment={x:0,y:0};var _activeSegment={x:0,y:0}; // Track the identifier of any input being tracked\n\tvar _inputIdentifier=false;var _inputIndex=0;var _inputCaptured=false; // Current scroll positions and tracking\n\tvar _isScrolling=false;var _isDisplayingScroll=false;var _isAnimating=false;var _baseScrollPosition={x:0,y:0};var _lastScrollPosition={x:0,y:0};var _targetScrollPosition={x:0,y:0};var _scrollAtExtremity={x:null,y:null};var _preventClick=false;var _timeouts=[];var _hasBeenScrolled=false; // Gesture details\n\tvar _baseScrollableAxes={};var _scrollableAxes={x:true,y:true};var _gestureStart={x:0,y:0,t:0};var _cumulativeScroll={x:0,y:0};var _eventHistory=[]; // Allow certain events to be debounced\n\tvar _domChangeDebouncer=false;var _scrollWheelEndDebouncer=false; // Performance switches on browsers supporting requestAnimationFrame\n\tvar _animationFrameRequest=false;var _reqAnimationFrame=window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || false;var _cancelAnimationFrame=window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || false; // Event listeners\n\tvar _eventListeners={'scrollstart':[],'scroll':[],'scrollend':[],'segmentwillchange':[],'segmentdidchange':[],'reachedstart':[],'reachedend':[],'scrollinteractionend':[]}; // MutationObserver instance, when supported and if DOM change sniffing is enabled\n\tvar _mutationObserver; /* Parsing supplied options */ // Override default instance options with global - or closure'd - options\n\tif(typeof FTScrollerOptions === 'object' && FTScrollerOptions){for(key in FTScrollerOptions) {if(FTScrollerOptions.hasOwnProperty(key) && _instanceOptions.hasOwnProperty(key)){_instanceOptions[key] = FTScrollerOptions[key];}}} // Override default and global options with supplied options\n\tif(options){for(key in options) {if(options.hasOwnProperty(key)){ // If a deprecated flag was passed in, warn, and convert to the new flag name\n\tif('paginatedSnap' === key){console.warn('FTScroller: \"paginatedSnap\" is deprecated; converting to \"singlePageScrolls\"');_instanceOptions.singlePageScrolls = options.paginatedSnap;continue;}if(_instanceOptions.hasOwnProperty(key)){_instanceOptions[key] = options[key];}}} // If snap grid size options were supplied, store them\n\tif(options.hasOwnProperty('snapSizeX') && !isNaN(options.snapSizeX)){_snapGridSize.userX = _snapGridSize.x = options.snapSizeX;}if(options.hasOwnProperty('snapSizeY') && !isNaN(options.snapSizeY)){_snapGridSize.userY = _snapGridSize.y = options.snapSizeY;} // If content width and height were defined, disable updateOnChanges for performance\n\tif(options.contentWidth && options.contentHeight){options.updateOnChanges = false;}} // Validate the scroll response parameter\n\t_instanceOptions.scrollResponseBoundary = Math.min(_instanceOptions.scrollBoundary,_instanceOptions.scrollResponseBoundary); // Update base scrollable axes\n\tif(_instanceOptions.scrollingX){_baseScrollableAxes.x = true;}if(_instanceOptions.scrollingY){_baseScrollableAxes.y = true;} // Only enable animation frame support if the instance options permit it\n\t_reqAnimationFrame = _instanceOptions.enableRequestAnimationFrameSupport && _reqAnimationFrame;_cancelAnimationFrame = _reqAnimationFrame && _cancelAnimationFrame; /*                    Scoped Functions                   */ /**\n\t\t\t * Unbinds all event listeners to prevent circular references preventing items\n\t\t\t * from being deallocated, and clean up references to dom elements. Pass in\n\t\t\t * \"removeElements\" to also remove FTScroller DOM elements for special reuse cases.\n\t\t\t */destroy = function destroy(removeElements){var i,l;_removeEventHandlers();_cancelAnimation();if(_domChangeDebouncer){window.clearTimeout(_domChangeDebouncer);_domChangeDebouncer = false;}for(i = 0,l = _timeouts.length;i < l;i = i + 1) {window.clearTimeout(_timeouts[i]);}_timeouts.length = 0; // Destroy DOM elements if required\n\tif(removeElements && _scrollableMasterNode){while(_contentParentNode.firstChild) {_scrollableMasterNode.appendChild(_contentParentNode.firstChild);}_scrollableMasterNode.removeChild(_containerNode);}_scrollableMasterNode = null;_containerNode = null;_contentParentNode = null;_scrollNodes.x = null;_scrollNodes.y = null;_scrollbarNodes.x = null;_scrollbarNodes.y = null;for(i in _eventListeners) {if(_eventListeners.hasOwnProperty(i)){_eventListeners[i].length = 0;}} // If this is currently tracked as a scrolling instance, clear the flag\n\tif(_ftscrollerMoving && _ftscrollerMoving === _self){_ftscrollerMoving = false;if(_instanceOptions.windowScrollingActiveFlag){window[_instanceOptions.windowScrollingActiveFlag] = false;}}}; /**\n\t\t\t * Configures the snapping boundaries within the scrolling element if\n\t\t\t * snapping is active.  If this is never called, snapping defaults to\n\t\t\t * using the bounding box, eg page-at-a-time.\n\t\t\t */setSnapSize = function setSnapSize(width,height){_snapGridSize.userX = width;_snapGridSize.userY = height;_snapGridSize.x = width;_snapGridSize.y = height; // Ensure the content dimensions conform to the grid\n\t_metrics.content.x = Math.ceil(_metrics.content.rawX / width) * width;_metrics.content.y = Math.ceil(_metrics.content.rawY / height) * height;_metrics.scrollEnd.x = _metrics.container.x - _metrics.content.x;_metrics.scrollEnd.y = _metrics.container.y - _metrics.content.y;_updateScrollbarDimensions(); // Snap to the new grid if necessary\n\t_snapScroll();_updateSegments(true);}; /**\n\t\t\t * Scroll to a supplied position, including whether or not to animate the\n\t\t\t * scroll and how fast to perform the animation (pass in true to select a\n\t\t\t * dynamic duration).  The inputs will be constrained to bounds and snapped.\n\t\t\t * If false is supplied for a position, that axis will not be scrolled.\n\t\t\t */scrollTo = function scrollTo(left,top,animationDuration){var targetPosition,duration,positions,axis,maxDuration=0,scrollPositionsToApply={}; // If a manual scroll is in progress, cancel it\n\t_endScroll(Date.now()); // Move supplied coordinates into an object for iteration, also inverting the values into\n\t// our coordinate system\n\tpositions = {x:-left,y:-top};for(axis in _baseScrollableAxes) {if(_baseScrollableAxes.hasOwnProperty(axis)){targetPosition = positions[axis];if(targetPosition === false){continue;} // Constrain to bounds\n\ttargetPosition = Math.min(0,Math.max(_metrics.scrollEnd[axis],targetPosition)); // Snap if appropriate\n\tif(_instanceOptions.snapping && _snapGridSize[axis]){targetPosition = Math.round(targetPosition / _snapGridSize[axis]) * _snapGridSize[axis];} // Get a duration\n\tduration = animationDuration || 0;if(duration === true){duration = Math.sqrt(Math.abs(_baseScrollPosition[axis] - targetPosition)) * 20;} // Trigger the position change\n\t_setAxisPosition(axis,targetPosition,duration);scrollPositionsToApply[axis] = targetPosition;maxDuration = Math.max(maxDuration,duration);}} // If the scroll had resulted in a change in position, perform some additional actions:\n\tif(_baseScrollPosition.x !== positions.x || _baseScrollPosition.y !== positions.y){ // Mark a scroll as having ever occurred\n\t_hasBeenScrolled = true; // If an animation duration is present, fire a scroll start event and a\n\t// scroll event for any listeners to act on\n\t_fireEvent('scrollstart',_getPosition());_fireEvent('scroll',_getPosition());}if(maxDuration){_timeouts.push(setTimeout(function(){var anAxis;for(anAxis in scrollPositionsToApply) {if(scrollPositionsToApply.hasOwnProperty(anAxis)){_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];}}_finalizeScroll();},maxDuration));}else {_finalizeScroll();}}; /**\n\t\t\t * Alter the current scroll position, including whether or not to animate\n\t\t\t * the scroll and how fast to perform the animation (pass in true to\n\t\t\t * select a dynamic duration).  The inputs will be checked against the\n\t\t\t * current position.\n\t\t\t */scrollBy = function scrollBy(horizontal,vertical,animationDuration){ // Wrap the scrollTo function for simplicity\n\tscrollTo(parseFloat(horizontal) - _baseScrollPosition.x,parseFloat(vertical) - _baseScrollPosition.y,animationDuration);}; /**\n\t\t\t * Provide a public method to detect changes in dimensions for either the content or the\n\t\t\t * container.\n\t\t\t */updateDimensions = function updateDimensions(contentWidth,contentHeight,ignoreSnapScroll){options.contentWidth = contentWidth || options.contentWidth;options.contentHeight = contentHeight || options.contentHeight; // Currently just wrap the private API\n\t_updateDimensions(!!ignoreSnapScroll);}; /**\n\t\t\t * Add an event handler for a supported event.  Current events include:\n\t\t\t * scroll - fired whenever the scroll position changes\n\t\t\t * scrollstart - fired when a scroll movement starts\n\t\t\t * scrollend - fired when a scroll movement ends\n\t\t\t * segmentwillchange - fired whenever the segment changes, including during scrolling\n\t\t\t * segmentdidchange - fired when a segment has conclusively changed, after scrolling.\n\t\t\t */addEventListener = function addEventListener(eventname,eventlistener){ // Ensure this is a valid event\n\tif(!_eventListeners.hasOwnProperty(eventname)){return false;} // Add the listener\n\t_eventListeners[eventname].push(eventlistener);return true;}; /**\n\t\t\t * Remove an event handler for a supported event.  The listener must be exactly the same as\n\t\t\t * an added listener to be removed.\n\t\t\t */removeEventListener = function removeEventListener(eventname,eventlistener){var i; // Ensure this is a valid event\n\tif(!_eventListeners.hasOwnProperty(eventname)){return false;}for(i = _eventListeners[eventname].length;i >= 0;i = i - 1) {if(_eventListeners[eventname][i] === eventlistener){_eventListeners[eventname].splice(i,1);}}return true;}; /**\n\t\t\t * Set the input methods to disable. No inputs methods are disabled by default.\n\t\t\t * (object, default { mouse: false, touch: false, scroll: false, pointer: false, focus: false })\n\t\t\t */setDisabledInputMethods = function setDisabledInputMethods(disabledInputMethods){var i,changed;for(i in _instanceOptions.disabledInputMethods) {disabledInputMethods[i] = !!disabledInputMethods[i];if(_instanceOptions.disabledInputMethods[i] !== disabledInputMethods[i])changed = true;_instanceOptions.disabledInputMethods[i] = disabledInputMethods[i];}if(changed){_resetEventHandlers();}}; /**\n\t\t\t * Start a scroll tracking input - this could be mouse, webkit-style touch,\n\t\t\t * or ms-style pointer events.\n\t\t\t */_startScroll = function _startScroll(inputX,inputY,inputTime,rawEvent){var triggerScrollInterrupt=_isAnimating; // Opera fix\n\tif(inputTime <= 0){inputTime = Date.now();} // If a window scrolling flag is set, and evaluates to true, don't start checking touches\n\tif(_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]){return false;} // If an animation is in progress, stop the scroll.\n\tif(triggerScrollInterrupt){_interruptScroll();}else { // Allow clicks again, but only if a scroll was not interrupted\n\t_preventClick = false;} // Store the initial event coordinates\n\t_gestureStart.x = inputX;_gestureStart.y = inputY;_gestureStart.t = inputTime;_targetScrollPosition.x = _lastScrollPosition.x;_targetScrollPosition.y = _lastScrollPosition.y; // Clear event history and add the start touch\n\t_eventHistory.length = 0;_eventHistory.push({x:inputX,y:inputY,t:inputTime});if(triggerScrollInterrupt){_updateScroll(inputX,inputY,inputTime,rawEvent,triggerScrollInterrupt);}return true;}; /**\n\t\t\t * Continue a scroll as a result of an updated position\n\t\t\t */_updateScroll = function _updateScroll(inputX,inputY,inputTime,rawEvent,scrollInterrupt){var axis,otherScrollerActive,distancesBeyondBounds;var initialScroll=false;var gesture={x:inputX - _gestureStart.x,y:inputY - _gestureStart.y}; // Opera fix\n\tif(inputTime <= 0){inputTime = Date.now();} // Update base target positions\n\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;_targetScrollPosition.y = _baseScrollPosition.y + gesture.y; // If scrolling has not yet locked to this scroller, check whether to stop scrolling\n\tif(!_isScrolling){ // Check the internal flag to determine if another FTScroller is scrolling\n\tif(_ftscrollerMoving && _ftscrollerMoving !== _self){otherScrollerActive = true;} // Otherwise, check the window scrolling flag to see if anything else has claimed scrolling\n\telse if(_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]){otherScrollerActive = true;} // If another scroller was active, clean up and stop processing.\n\tif(otherScrollerActive){_releaseInputCapture();_inputIdentifier = false;if(_isDisplayingScroll){_cancelAnimation();if(!_snapScroll(true)){_finalizeScroll(true);}}return;}} // If not yet displaying a scroll, determine whether that triggering boundary\n\t// has been exceeded\n\tif(!_isDisplayingScroll){ // Determine scroll distance beyond bounds\n\tdistancesBeyondBounds = _distancesBeyondBounds(_targetScrollPosition); // Determine whether to prevent the default scroll event - if the scroll could still\n\t// be triggered, prevent the default to avoid problems (particularly on PlayBook)\n\tif(_instanceOptions.bouncing || scrollInterrupt || _scrollableAxes.x && gesture.x && distancesBeyondBounds.x < 0 || _scrollableAxes.y && gesture.y && distancesBeyondBounds.y < 0){rawEvent.preventDefault();} // Check scrolled distance against the boundary limit to see if scrolling can be triggered.\n\t// If the scroll has been interrupted, trigger at once\n\tif(!scrollInterrupt && (!_scrollableAxes.x || Math.abs(gesture.x) < _instanceOptions.scrollResponseBoundary) && (!_scrollableAxes.y || Math.abs(gesture.y) < _instanceOptions.scrollResponseBoundary)){return;} // If bouncing is disabled, and already at an edge and scrolling beyond the edge, ignore the scroll for\n\t// now - this allows other scrollers to claim if appropriate, allowing nicer nested scrolls.\n\tif(!_instanceOptions.bouncing && !scrollInterrupt && (!_scrollableAxes.x || !gesture.x || distancesBeyondBounds.x > 0) && (!_scrollableAxes.y || !gesture.y || distancesBeyondBounds.y > 0)){ // Prevent the original click now that scrolling would be triggered\n\t_preventClick = true;return;} // Trigger the start of visual scrolling\n\t_startAnimation();_isDisplayingScroll = true;_hasBeenScrolled = true;_isAnimating = true;initialScroll = true;}else { // Prevent the event default.  It is safe to call this in IE10 because the event is never\n\t// a window.event, always a \"true\" event.\n\trawEvent.preventDefault();} // If not yet locked to a scroll, determine whether to do so\n\tif(!_isScrolling){ // If the gesture distance has exceeded the scroll lock distance, or snapping is active\n\t// and the scroll has been interrupted, enter exclusive scrolling.\n\tif(scrollInterrupt && _instanceOptions.snapping || _scrollableAxes.x && Math.abs(gesture.x) >= _instanceOptions.scrollBoundary || _scrollableAxes.y && Math.abs(gesture.y) >= _instanceOptions.scrollBoundary){_isScrolling = true;_preventClick = true;_ftscrollerMoving = _self;if(_instanceOptions.windowScrollingActiveFlag){window[_instanceOptions.windowScrollingActiveFlag] = _self;}_fireEvent('scrollstart',_getPosition());}} // Capture pointer if necessary\n\tif(_isScrolling){_captureInput();} // Cancel text selections while dragging a cursor\n\tif(_canClearSelection){window.getSelection().removeAllRanges();} // Ensure the target scroll position is affected by bounds and render if needed\n\t_constrainAndRenderTargetScrollPosition(); // To aid render/draw coalescing, perform other one-off actions here\n\tif(initialScroll){if(gesture.x > 0){_baseScrollPosition.x -= _instanceOptions.scrollResponseBoundary;}else if(gesture.x < 0){_baseScrollPosition.x += _instanceOptions.scrollResponseBoundary;}if(gesture.y > 0){_baseScrollPosition.y -= _instanceOptions.scrollResponseBoundary;}else if(gesture.y < 0){_baseScrollPosition.y += _instanceOptions.scrollResponseBoundary;}_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;if(_instanceOptions.scrollingClassName){_containerNode.className += ' ' + _instanceOptions.scrollingClassName;}if(_instanceOptions.scrollbars){for(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){_scrollbarNodes[axis].className += ' active';}}}} // Add an event to the event history, keeping it around twenty events long\n\t_eventHistory.push({x:inputX,y:inputY,t:inputTime});if(_eventHistory.length > 30){_eventHistory.splice(0,15);}}; /**\n\t\t\t * Complete a scroll with a final event time if available (it may\n\t\t\t * not be, depending on the input type); this may continue the scroll\n\t\t\t * with a fling and/or bounceback depending on options.\n\t\t\t */_endScroll = function _endScroll(inputTime,rawEvent){_releaseInputCapture();_inputIdentifier = false;_cancelAnimation();_fireEvent('scrollinteractionend',{});if(!_isScrolling){if(!_snapScroll(true) && _isDisplayingScroll){_finalizeScroll(true);}return;} // Modify the last movement event to include the end event time\n\t_eventHistory[_eventHistory.length - 1].t = inputTime; // Update flags\n\t_isScrolling = false;_isDisplayingScroll = false;_ftscrollerMoving = false;if(_instanceOptions.windowScrollingActiveFlag){window[_instanceOptions.windowScrollingActiveFlag] = false;} // Stop the event default.  It is safe to call this in IE10 because\n\t// the event is never a window.event, always a \"true\" event.\n\tif(rawEvent){rawEvent.preventDefault();} // Trigger a fling or bounceback if necessary\n\tif(!_flingScroll() && !_snapScroll()){_finalizeScroll();}}; /**\n\t\t\t * Remove the scrolling class, cleaning up display.\n\t\t\t */_finalizeScroll = function _finalizeScroll(scrollCancelled){var i,l,axis,scrollEvent,scrollRegex;_isAnimating = false;_isDisplayingScroll = false; // Remove scrolling class if set\n\tif(_instanceOptions.scrollingClassName){scrollRegex = new RegExp('(?:^|\\\\s)' + _instanceOptions.scrollingClassName + '(?!\\\\S)','g');_containerNode.className = _containerNode.className.replace(scrollRegex,'');}if(_instanceOptions.scrollbars){for(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){_scrollbarNodes[axis].className = _scrollbarNodes[axis].className.replace(/ ?active/g,'');}}} // Store final position if scrolling occurred\n\t_baseScrollPosition.x = _lastScrollPosition.x;_baseScrollPosition.y = _lastScrollPosition.y;scrollEvent = _getPosition();if(!scrollCancelled){_fireEvent('scroll',scrollEvent);_updateSegments(true);} // Always fire the scroll end event, including an argument indicating whether\n\t// the scroll was cancelled\n\tscrollEvent.cancelled = scrollCancelled;_fireEvent('scrollend',scrollEvent); // Restore transitions\n\tfor(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){_scrollNodes[axis].style[_transitionProperty] = '';if(_instanceOptions.scrollbars){_scrollbarNodes[axis].style[_transitionProperty] = '';}}} // Clear any remaining timeouts\n\tfor(i = 0,l = _timeouts.length;i < l;i = i + 1) {window.clearTimeout(_timeouts[i]);}_timeouts.length = 0;}; /**\n\t\t\t * Interrupt a current scroll, allowing a start scroll during animation to trigger a new scroll\n\t\t\t */_interruptScroll = function _interruptScroll(){var axis,i,l;_isAnimating = false; // Update the stored base position\n\t_updateElementPosition(); // Ensure the parsed positions are set, also clearing transitions\n\tfor(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){_setAxisPosition(axis,_baseScrollPosition[axis],16,_instanceOptions.bounceDecelerationBezier);}} // Update segment tracking if snapping is active\n\t_updateSegments(false); // Clear any remaining timeouts\n\tfor(i = 0,l = _timeouts.length;i < l;i = i + 1) {window.clearTimeout(_timeouts[i]);}_timeouts.length = 0;}; /**\n\t\t\t * Determine whether a scroll fling or bounceback is required, and set up the styles and\n\t\t\t * timeouts required.\n\t\t\t */_flingScroll = function _flingScroll(){var i,axis,movementTime,movementSpeed,lastPosition,comparisonPosition,flingDuration,flingDistance,flingPosition,bounceDelay,bounceDistance,bounceDuration,bounceTarget,boundsBounce,modifiedDistance,flingBezier,timeProportion,boundsCrossDelay,flingStartSegment,beyondBoundsFlingDistance,baseFlingComponent;var maxAnimationTime=0;var moveRequired=false;var scrollPositionsToApply={}; // If we only have the start event available, or flinging is disabled,\n\t// or the scroll was triggered by a scrollwheel, no action required.\n\tif(_eventHistory.length === 1 || !_instanceOptions.flinging || _inputIdentifier === 'scrollwheel'){return false;}for(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){bounceDuration = 350;bounceDistance = 0;boundsBounce = false;bounceTarget = false;boundsCrossDelay = undefined; // Re-set a default bezier curve for the animation for potential modification\n\tflingBezier = _instanceOptions.flingBezier; // Get the last movement speed, in pixels per millisecond.  To do this, look at the events\n\t// in the last 100ms and average out the speed, using a minimum number of two points.\n\tlastPosition = _eventHistory[_eventHistory.length - 1];comparisonPosition = _eventHistory[_eventHistory.length - 2];for(i = _eventHistory.length - 3;i >= 0;i = i - 1) {if(lastPosition.t - _eventHistory[i].t > 100){break;}comparisonPosition = _eventHistory[i];} // Get the last movement time.  If this is zero - as can happen with\n\t// some scrollwheel events on some platforms - increase it to 16ms as\n\t// if the movement occurred over a single frame at 60fps.\n\tmovementTime = lastPosition.t - comparisonPosition.t;if(!movementTime){movementTime = 16;} // Derive the movement speed\n\tmovementSpeed = (lastPosition[axis] - comparisonPosition[axis]) / movementTime; // If there is little speed, no further action required except for a bounceback, below.\n\tif(Math.abs(movementSpeed) < _kMinimumSpeed){flingDuration = 0;flingDistance = 0;}else { /* Calculate the fling duration.  As per TouchScroll, the speed at any particular\n\t\t\t\t\t\t\tpoint in time can be calculated as:\n\t\t\t\t\t\t\t\t{ speed } = { initial speed } * ({ friction } to the power of { duration })\n\t\t\t\t\t\t\t...assuming all values are in equal pixels/millisecond measurements.  As we know the\n\t\t\t\t\t\t\tminimum target speed, this can be altered to:\n\t\t\t\t\t\t\t\t{ duration } = log( { speed } / { initial speed } ) / log( { friction } )\n\t\t\t\t\t\t\t*/flingDuration = Math.log(_kMinimumSpeed / Math.abs(movementSpeed)) / Math.log(_kFriction); /* Calculate the fling distance (before any bouncing or snapping).  As per\n\t\t\t\t\t\t\tTouchScroll, the total distance covered can be approximated by summing\n\t\t\t\t\t\t\tthe distance per millisecond, per millisecond of duration - a divergent series,\n\t\t\t\t\t\t\tand so rather tricky to model otherwise!\n\t\t\t\t\t\t\tSo using values in pixels per millisecond:\n\t\t\t\t\t\t\t\t{ distance } = { initial speed } * (1 - ({ friction } to the power\n\t\t\t\t\t\t\t\t\tof { duration + 1 }) / (1 - { friction })\n\t\t\t\t\t\t\t*/flingDistance = movementSpeed * (1 - Math.pow(_kFriction,flingDuration + 1)) / (1 - _kFriction);} // Determine a target fling position\n\tflingPosition = Math.floor(_lastScrollPosition[axis] + flingDistance); // If bouncing is disabled, and the last scroll position and fling position are both at a bound,\n\t// reset the fling position to the bound\n\tif(!_instanceOptions.bouncing){if(_lastScrollPosition[axis] === 0 && flingPosition > 0){flingPosition = 0;}else if(_lastScrollPosition[axis] === _metrics.scrollEnd[axis] && flingPosition < _lastScrollPosition[axis]){flingPosition = _lastScrollPosition[axis];}} // In single-page-scroll mode, determine the page to snap to - maximum one page\n\t// in either direction from the *start* page.\n\tif(_instanceOptions.singlePageScrolls && _instanceOptions.snapping){flingStartSegment = -_lastScrollPosition[axis] / _snapGridSize[axis];if(_baseSegment[axis] < flingStartSegment){flingStartSegment = Math.floor(flingStartSegment);}else {flingStartSegment = Math.ceil(flingStartSegment);} // If the target position will end up beyond another page, target that page edge\n\tif(flingPosition > -(_baseSegment[axis] - 1) * _snapGridSize[axis]){bounceDistance = flingPosition + (_baseSegment[axis] - 1) * _snapGridSize[axis];}else if(flingPosition < -(_baseSegment[axis] + 1) * _snapGridSize[axis]){bounceDistance = flingPosition + (_baseSegment[axis] + 1) * _snapGridSize[axis]; // Otherwise, if the movement speed was above the minimum velocity, continue\n\t// in the move direction.\n\t}else if(Math.abs(movementSpeed) > _kMinimumSpeed){ // Determine the target segment\n\tif(movementSpeed < 0){flingPosition = Math.floor(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];}else {flingPosition = Math.ceil(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];}flingDuration = Math.min(_instanceOptions.maxFlingDuration,flingDuration * (flingPosition - _lastScrollPosition[axis]) / flingDistance);} // In non-paginated snapping mode, snap to the nearest grid location to the target\n\t}else if(_instanceOptions.snapping){bounceDistance = flingPosition - Math.round(flingPosition / _snapGridSize[axis]) * _snapGridSize[axis];} // Deal with cases where the target is beyond the bounds\n\tif(flingPosition - bounceDistance > 0){bounceDistance = flingPosition;boundsBounce = true;}else if(flingPosition - bounceDistance < _metrics.scrollEnd[axis]){bounceDistance = flingPosition - _metrics.scrollEnd[axis];boundsBounce = true;} // Amend the positions and bezier curve if necessary\n\tif(bounceDistance){ // If the fling moves the scroller beyond the normal scroll bounds, and\n\t// the bounce is snapping the scroll back after the fling:\n\tif(boundsBounce && _instanceOptions.bouncing && flingDistance){flingDistance = Math.floor(flingDistance);if(flingPosition > 0){beyondBoundsFlingDistance = flingPosition - Math.max(0,_lastScrollPosition[axis]);}else {beyondBoundsFlingDistance = flingPosition - Math.min(_metrics.scrollEnd[axis],_lastScrollPosition[axis]);}baseFlingComponent = flingDistance - beyondBoundsFlingDistance; // Determine the time proportion the original bound is along the fling curve\n\tif(!flingDistance || !flingDuration){timeProportion = 0;}else {timeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((flingDistance - beyondBoundsFlingDistance) / flingDistance,1 / flingDuration),flingBezier._p1.x,flingBezier._p2.x);boundsCrossDelay = timeProportion * flingDuration;} // Eighth the distance beyonds the bounds\n\tmodifiedDistance = Math.ceil(beyondBoundsFlingDistance / 8); // Further limit the bounce to half the container dimensions\n\tif(Math.abs(modifiedDistance) > _metrics.container[axis] / 2){if(modifiedDistance < 0){modifiedDistance = -Math.floor(_metrics.container[axis] / 2);}else {modifiedDistance = Math.floor(_metrics.container[axis] / 2);}}if(flingPosition > 0){bounceTarget = 0;}else {bounceTarget = _metrics.scrollEnd[axis];} // If the entire fling is a bounce, modify appropriately\n\tif(timeProportion === 0){flingDuration = flingDuration / 6;flingPosition = _lastScrollPosition[axis] + baseFlingComponent + modifiedDistance;bounceDelay = flingDuration; // Otherwise, take a new curve and add it to the timeout stack for the bounce\n\t}else { // The new bounce delay is the pre-boundary fling duration, plus a\n\t// sixth of the post-boundary fling.\n\tbounceDelay = (timeProportion + (1 - timeProportion) / 6) * flingDuration;_scheduleAxisPosition(axis,_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance,(1 - timeProportion) * flingDuration / 6,_instanceOptions.bounceDecelerationBezier,boundsCrossDelay); // Modify the fling to match, clipping to prevent over-fling\n\tflingBezier = flingBezier.divideAtX(bounceDelay / flingDuration,1 / flingDuration)[0];flingDuration = bounceDelay;flingPosition = _lastScrollPosition[axis] + baseFlingComponent + modifiedDistance;} // If the fling requires snapping to a snap location, and the bounce needs to\n\t// reverse the fling direction after the fling completes:\n\t}else if(flingDistance < 0 && bounceDistance < flingDistance || flingDistance > 0 && bounceDistance > flingDistance){ // Shorten the original fling duration to reflect the bounce\n\tflingPosition = flingPosition - Math.floor(flingDistance / 2);bounceDistance = bounceDistance - Math.floor(flingDistance / 2);bounceDuration = Math.sqrt(Math.abs(bounceDistance)) * 50;bounceTarget = flingPosition - bounceDistance;flingDuration = 350;bounceDelay = flingDuration * 0.97; // If the bounce is truncating the fling, or continuing the fling on in the same\n\t// direction to hit the next boundary:\n\t}else {flingPosition = flingPosition - bounceDistance; // If there was no fling distance originally, use the bounce details\n\tif(!flingDistance){flingDuration = bounceDuration; // If truncating the fling at a snapping edge:\n\t}else if(flingDistance < 0 && bounceDistance < 0 || flingDistance > 0 && bounceDistance > 0){timeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((Math.abs(flingDistance) - Math.abs(bounceDistance)) / Math.abs(flingDistance),1 / flingDuration),flingBezier._p1.x,flingBezier._p2.x);flingBezier = flingBezier.divideAtX(timeProportion,1 / flingDuration)[0];flingDuration = Math.round(flingDuration * timeProportion); // If extending the fling to reach the next snapping boundary, no further\n\t// action is required.\n\t}bounceDistance = 0;bounceDuration = 0;}} // If no fling or bounce is required, continue\n\tif(flingPosition === _lastScrollPosition[axis] && !bounceDistance){continue;}moveRequired = true; // Perform the fling\n\t_setAxisPosition(axis,flingPosition,flingDuration,flingBezier,boundsCrossDelay); // Schedule a bounce if appropriate\n\tif(bounceDistance && bounceDuration){_scheduleAxisPosition(axis,bounceTarget,bounceDuration,_instanceOptions.bounceBezier,bounceDelay);}maxAnimationTime = Math.max(maxAnimationTime,bounceDistance?bounceDelay + bounceDuration:flingDuration);scrollPositionsToApply[axis] = bounceTarget === false?flingPosition:bounceTarget;}}if(moveRequired && maxAnimationTime){_timeouts.push(setTimeout(function(){var anAxis; // Update the stored scroll position ready for finalising\n\tfor(anAxis in scrollPositionsToApply) {if(scrollPositionsToApply.hasOwnProperty(anAxis)){_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];}}_finalizeScroll();},maxAnimationTime));}return moveRequired;}; /**\n\t\t\t * Bounce back into bounds if necessary, or snap to a grid location.\n\t\t\t */_snapScroll = function _snapScroll(scrollCancelled){var axis;var snapDuration=scrollCancelled?100:350;var targetPosition=_lastScrollPosition; // Get the current position and see if a snap is required\n\tif(_instanceOptions.snapping){ // Store current snap index\n\t_snapIndex = _getSnapIndexForPosition(targetPosition);targetPosition = _getSnapPositionForIndexes(_snapIndex,targetPosition);}targetPosition = _limitToBounds(targetPosition);var snapRequired=false;for(axis in _baseScrollableAxes) {if(_baseScrollableAxes.hasOwnProperty(axis)){if(targetPosition[axis] !== _lastScrollPosition[axis]){snapRequired = true;}}}if(!snapRequired){return false;} // Perform the snap\n\tfor(axis in _baseScrollableAxes) {if(_baseScrollableAxes.hasOwnProperty(axis)){_setAxisPosition(axis,targetPosition[axis],snapDuration);}}_timeouts.push(setTimeout(function(){ // Update the stored scroll position ready for finalizing\n\t_lastScrollPosition = targetPosition;_finalizeScroll(scrollCancelled);},snapDuration));return true;}; /**\n\t\t\t * Get an appropriate snap index for a supplied point.\n\t\t\t */_getSnapIndexForPosition = function _getSnapIndexForPosition(coordinates){var axis;var indexes={x:0,y:0};for(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis) && _snapGridSize[axis]){indexes[axis] = Math.round(coordinates[axis] / _snapGridSize[axis]);}}return indexes;}; /**\n\t\t\t * Get an appropriate snap point for a supplied index.\n\t\t\t */_getSnapPositionForIndexes = function _getSnapPositionForIndexes(indexes,currentCoordinates){var axis;var coordinatesToReturn={x:currentCoordinates.x,y:currentCoordinates.y};for(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){coordinatesToReturn[axis] = indexes[axis] * _snapGridSize[axis];}}return coordinatesToReturn;}; /**\n\t\t\t * Update the scroll position while scrolling is active, checking the position\n\t\t\t * within bounds and rubberbanding/constraining as appropriate; also triggers a\n\t\t\t * scroll position render if a requestAnimationFrame loop isn't active\n\t\t\t */_constrainAndRenderTargetScrollPosition = function _constrainAndRenderTargetScrollPosition(){var axis,upperBound,lowerBound; // Update axes target positions if beyond bounds\n\tfor(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){ // Set bounds to the left and right of the container\n\tupperBound = 0;lowerBound = _metrics.scrollEnd[axis];if(_instanceOptions.singlePageScrolls && _instanceOptions.snapping){ // For a single-page-scroll, set the bounds to the left and right of the\n\t// current segment\n\tupperBound = Math.min(upperBound,-(_baseSegment[axis] - 1) * _snapGridSize[axis]);lowerBound = Math.max(lowerBound,-(_baseSegment[axis] + 1) * _snapGridSize[axis]);}if(_targetScrollPosition[axis] > upperBound){_targetScrollPosition[axis] = upperBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - upperBound,axis);}else if(_targetScrollPosition[axis] < lowerBound){_targetScrollPosition[axis] = lowerBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - lowerBound,axis);}}} // Trigger a scroll position update for platforms not using requestAnimationFrames\n\tif(!_reqAnimationFrame){_scheduleRender();}}; /**\n\t\t\t * Limit coordinates within the bounds of the scrollable viewport.\n\t\t\t */_limitToBounds = function _limitToBounds(coordinates){var axis;var coordinatesToReturn={x:coordinates.x,y:coordinates.y};for(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){ // If the coordinate is beyond the edges of the scroller, use the closest edge\n\tif(coordinates[axis] > 0){coordinatesToReturn[axis] = 0;continue;}if(coordinates[axis] < _metrics.scrollEnd[axis]){coordinatesToReturn[axis] = _metrics.scrollEnd[axis];continue;}}}return coordinatesToReturn;}; /**\n\t\t\t * Sets up the DOM around the node to be scrolled.\n\t\t\t */_initializeDOM = function _initializeDOM(){var offscreenFragment,offscreenNode,scrollYParent; // Check whether the DOM is already present and valid - if so, no further action required.\n\tif(_existingDOMValid()){return;} // Otherwise, the DOM needs to be created inside the originally supplied node.  The node\n\t// has a container inserted inside it - which acts as an anchor element with constraints -\n\t// and then the scrollable layers as appropriate.\n\t// Create a new document fragment to temporarily hold the scrollable content\n\toffscreenFragment = _scrollableMasterNode.ownerDocument.createDocumentFragment();offscreenNode = document.createElement('DIV');offscreenFragment.appendChild(offscreenNode); // Drop in the wrapping HTML\n\toffscreenNode.innerHTML = FTScroller.prototype.getPrependedHTML(!_instanceOptions.scrollingX,!_instanceOptions.scrollingY,_instanceOptions.hwAccelerationClass) + FTScroller.prototype.getAppendedHTML(!_instanceOptions.scrollingX,!_instanceOptions.scrollingY,_instanceOptions.hwAccelerationClass,_instanceOptions.scrollbars); // Update references as appropriate\n\t_containerNode = offscreenNode.firstElementChild;scrollYParent = _containerNode;if(_instanceOptions.scrollingX){_scrollNodes.x = _containerNode.firstElementChild;scrollYParent = _scrollNodes.x;if(_instanceOptions.scrollbars){_scrollbarNodes.x = _containerNode.getElementsByClassName('ftscroller_scrollbarx')[0];}}if(_instanceOptions.scrollingY){_scrollNodes.y = scrollYParent.firstElementChild;if(_instanceOptions.scrollbars){_scrollbarNodes.y = _containerNode.getElementsByClassName('ftscroller_scrollbary')[0];}_contentParentNode = _scrollNodes.y;}else {_contentParentNode = _scrollNodes.x;} // Take the contents of the scrollable element, and copy them into the new container\n\twhile(_scrollableMasterNode.firstChild) {_contentParentNode.appendChild(_scrollableMasterNode.firstChild);} // Move the wrapped elements back into the document\n\t_scrollableMasterNode.appendChild(_containerNode);}; /**\n\t\t\t * Attempts to use any existing DOM scroller nodes if possible, returning true if so;\n\t\t\t * updates all internal element references.\n\t\t\t */_existingDOMValid = function _existingDOMValid(){var scrollerContainer,layerX,layerY,yParent,scrollerX,scrollerY,candidates,i,l; // Check that there's an initial child node, and make sure it's the container class\n\tscrollerContainer = _scrollableMasterNode.firstElementChild;if(!scrollerContainer || scrollerContainer.className.indexOf('ftscroller_container') === -1){return;} // If x-axis scrolling is enabled, find and verify the x scroller layer\n\tif(_instanceOptions.scrollingX){ // Find and verify the x scroller layer\n\tlayerX = scrollerContainer.firstElementChild;if(!layerX || layerX.className.indexOf('ftscroller_x') === -1){return;}yParent = layerX; // Find and verify the x scrollbar if enabled\n\tif(_instanceOptions.scrollbars){candidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbarx');if(candidates){for(i = 0,l = candidates.length;i < l;i = i + 1) {if(candidates[i].parentNode === scrollerContainer){scrollerX = candidates[i];break;}}}if(!scrollerX){return;}}}else {yParent = scrollerContainer;} // If y-axis scrolling is enabled, find and verify the y scroller layer\n\tif(_instanceOptions.scrollingY){ // Find and verify the x scroller layer\n\tlayerY = yParent.firstElementChild;if(!layerY || layerY.className.indexOf('ftscroller_y') === -1){return;} // Find and verify the y scrollbar if enabled\n\tif(_instanceOptions.scrollbars){candidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbary');if(candidates){for(i = 0,l = candidates.length;i < l;i = i + 1) {if(candidates[i].parentNode === scrollerContainer){scrollerY = candidates[i];break;}}}if(!scrollerY){return;}}} // Elements found and verified - update the references and return success\n\t_containerNode = scrollerContainer;if(layerX){_scrollNodes.x = layerX;}if(layerY){_scrollNodes.y = layerY;}if(scrollerX){_scrollbarNodes.x = scrollerX;}if(scrollerY){_scrollbarNodes.y = scrollerY;}if(_instanceOptions.scrollingY){_contentParentNode = layerY;}else {_contentParentNode = layerX;}return true;};_domChanged = function _domChanged(e){ // If the timer is active, clear it\n\tif(_domChangeDebouncer){window.clearTimeout(_domChangeDebouncer);} // React to resizes at once\n\tif(e && e.type === 'resize'){_updateDimensions(); // For other changes, which may occur in groups, set up the DOM changed timer\n\t}else {_domChangeDebouncer = setTimeout(function(){_updateDimensions();},100);}};_updateDimensions = function _updateDimensions(ignoreSnapScroll){var axis; // Only update dimensions if the container node exists (DOM elements can go away if\n\t// the scroller instance is not destroyed correctly)\n\tif(!_containerNode || !_contentParentNode){return false;}if(_domChangeDebouncer){window.clearTimeout(_domChangeDebouncer);_domChangeDebouncer = false;}var containerWidth,containerHeight,startAlignments; // Calculate the starting alignment for comparison later\n\tstartAlignments = {x:false,y:false};for(axis in startAlignments) {if(startAlignments.hasOwnProperty(axis)){if(_lastScrollPosition[axis] === 0){startAlignments[axis] = -1;}else if(_lastScrollPosition[axis] <= _metrics.scrollEnd[axis]){startAlignments[axis] = 1;}else if(_lastScrollPosition[axis] * 2 <= _metrics.scrollEnd[axis] + 5 && _lastScrollPosition[axis] * 2 >= _metrics.scrollEnd[axis] - 5){startAlignments[axis] = 0;}}}containerWidth = _containerNode.offsetWidth;containerHeight = _containerNode.offsetHeight; // Grab the dimensions\n\tvar rawScrollWidth=options.contentWidth || _contentParentNode.offsetWidth;var rawScrollHeight=options.contentHeight || _contentParentNode.offsetHeight;var scrollWidth=rawScrollWidth;var scrollHeight=rawScrollHeight;var targetPosition={x:_lastScrollPosition.x,y:_lastScrollPosition.y}; // Update snap grid\n\tif(!_snapGridSize.userX){_snapGridSize.x = containerWidth;}if(!_snapGridSize.userY){_snapGridSize.y = containerHeight;} // If there is a grid, conform to the grid\n\tif(_instanceOptions.snapping){if(_snapGridSize.userX){scrollWidth = Math.ceil(scrollWidth / _snapGridSize.userX) * _snapGridSize.userX;}else {scrollWidth = Math.ceil(scrollWidth / _snapGridSize.x) * _snapGridSize.x;}if(_snapGridSize.userY){scrollHeight = Math.ceil(scrollHeight / _snapGridSize.userY) * _snapGridSize.userY;}else {scrollHeight = Math.ceil(scrollHeight / _snapGridSize.y) * _snapGridSize.y;}} // If no details have changed, return.\n\tif(_metrics.container.x === containerWidth && _metrics.container.y === containerHeight && _metrics.content.x === scrollWidth && _metrics.content.y === scrollHeight){return;} // Update the sizes\n\t_metrics.container.x = containerWidth;_metrics.container.y = containerHeight;_metrics.content.x = scrollWidth;_metrics.content.rawX = rawScrollWidth;_metrics.content.y = scrollHeight;_metrics.content.rawY = rawScrollHeight;_metrics.scrollEnd.x = containerWidth - scrollWidth;_metrics.scrollEnd.y = containerHeight - scrollHeight;_updateScrollbarDimensions(); // If scrolling is in progress, trigger a scroll update\n\tif(_isScrolling){_lastScrollPosition.x--;_lastScrollPosition.y--;_constrainAndRenderTargetScrollPosition(); // If scrolling *isn't* in progress, snap and realign.\n\t}else {if(!ignoreSnapScroll && _instanceOptions.snapping){ // Ensure bounds are correct\n\t_updateSegments();targetPosition = _getSnapPositionForIndexes(_snapIndex,_lastScrollPosition);} // Apply base alignment if appropriate\n\tfor(axis in targetPosition) {if(targetPosition.hasOwnProperty(axis)){ // If the container is smaller than the content, determine whether to apply the\n\t// alignment.  This occurs if a scroll has never taken place, or if the position\n\t// was previously at the correct \"end\" and can be maintained.\n\tif(_metrics.container[axis] < _metrics.content[axis]){if(_hasBeenScrolled && _instanceOptions.baseAlignments[axis] !== startAlignments[axis]){continue;}} // Apply the alignment\n\tif(_instanceOptions.baseAlignments[axis] === 1){targetPosition[axis] = _metrics.scrollEnd[axis];}else if(_instanceOptions.baseAlignments[axis] === 0){targetPosition[axis] = Math.floor(_metrics.scrollEnd[axis] / 2);}else if(_instanceOptions.baseAlignments[axis] === -1){targetPosition[axis] = 0;}}} // Limit to bounds\n\ttargetPosition = _limitToBounds(targetPosition);if(_instanceOptions.scrollingX && targetPosition.x !== _lastScrollPosition.x){_setAxisPosition('x',targetPosition.x,0);_baseScrollPosition.x = targetPosition.x;}if(_instanceOptions.scrollingY && targetPosition.y !== _lastScrollPosition.y){_setAxisPosition('y',targetPosition.y,0);_baseScrollPosition.y = targetPosition.y;}}};_updateScrollbarDimensions = function _updateScrollbarDimensions(){ // Update scrollbar sizes\n\tif(_instanceOptions.scrollbars){if(_instanceOptions.scrollingX){_scrollbarNodes.x.style.width = Math.max(6,Math.round(_metrics.container.x * (_metrics.container.x / _metrics.content.x) - 4)) + 'px';}if(_instanceOptions.scrollingY){_scrollbarNodes.y.style.height = Math.max(6,Math.round(_metrics.container.y * (_metrics.container.y / _metrics.content.y) - 4)) + 'px';}} // Update scroll caches\n\t_scrollableAxes = {};if(_instanceOptions.scrollingX && (_metrics.content.x > _metrics.container.x || _instanceOptions.alwaysScroll)){_scrollableAxes.x = true;}if(_instanceOptions.scrollingY && (_metrics.content.y > _metrics.container.y || _instanceOptions.alwaysScroll)){_scrollableAxes.y = true;}};_updateElementPosition = function _updateElementPosition(){var axis,computedStyle,splitStyle; // Retrieve the current position of each active axis.\n\t// Custom parsing is used instead of native matrix support for speed and for\n\t// backwards compatibility.\n\tfor(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){computedStyle = window.getComputedStyle(_scrollNodes[axis],null)[_vendorTransformLookup];splitStyle = computedStyle.split(', '); // For 2d-style transforms, pull out elements four or five\n\tif(splitStyle.length === 6){_baseScrollPosition[axis] = parseInt(splitStyle[axis === 'y'?5:4],10); // For 3d-style transforms, pull out elements twelve or thirteen\n\t}else {_baseScrollPosition[axis] = parseInt(splitStyle[axis === 'y'?13:12],10);}_lastScrollPosition[axis] = _baseScrollPosition[axis];}}};_updateSegments = function _updateSegments(scrollFinalised){var axis;var newSegment={x:0,y:0}; // If snapping is disabled, return without any further action required\n\tif(!_instanceOptions.snapping){return;} // Calculate the new segments\n\tfor(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){newSegment[axis] = Math.max(0,Math.min(Math.ceil(_metrics.content[axis] / _snapGridSize[axis]) - 1,Math.round(-_lastScrollPosition[axis] / _snapGridSize[axis])));}} // In all cases update the active segment if appropriate\n\tif(newSegment.x !== _activeSegment.x || newSegment.y !== _activeSegment.y){_activeSegment.x = newSegment.x;_activeSegment.y = newSegment.y;_fireEvent('segmentwillchange',{segmentX:newSegment.x,segmentY:newSegment.y});} // If the scroll has been finalised, also update the base segment\n\tif(scrollFinalised){if(newSegment.x !== _baseSegment.x || newSegment.y !== _baseSegment.y){_baseSegment.x = newSegment.x;_baseSegment.y = newSegment.y;_fireEvent('segmentdidchange',{segmentX:newSegment.x,segmentY:newSegment.y});}}};_setAxisPosition = function _setAxisPosition(axis,position,animationDuration,animationBezier,boundsCrossDelay){var transitionCSSString,newPositionAtExtremity=null; // Only update position if the axis node exists (DOM elements can go away if\n\t// the scroller instance is not destroyed correctly)\n\tif(!_scrollNodes[axis]){return false;} // Determine the transition property to apply to both the scroll element and the scrollbar\n\tif(animationDuration){if(!animationBezier){animationBezier = _instanceOptions.flingBezier;}transitionCSSString = _vendorCSSPrefix + 'transform ' + animationDuration + 'ms ' + animationBezier.toString();}else {transitionCSSString = '';} // Apply the transition property to elements\n\t_scrollNodes[axis].style[_transitionProperty] = transitionCSSString;if(_instanceOptions.scrollbars){_scrollbarNodes[axis].style[_transitionProperty] = transitionCSSString;} // Update the positions\n\t_scrollNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + position + 'px' + _transformSuffixes[axis];if(_instanceOptions.scrollbars){_scrollbarNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + -position * _metrics.container[axis] / _metrics.content[axis] + 'px' + _transformSuffixes[axis];} // Determine whether the scroll is at an extremity.\n\tif(position >= 0){newPositionAtExtremity = 'start';}else if(position <= _metrics.scrollEnd[axis]){newPositionAtExtremity = 'end';} // If the extremity status has changed, fire an appropriate event\n\tif(newPositionAtExtremity !== _scrollAtExtremity[axis]){if(newPositionAtExtremity !== null){if(animationDuration){_timeouts.push(setTimeout(function(){_fireEvent('reached' + newPositionAtExtremity,{axis:axis});},boundsCrossDelay || animationDuration));}else {_fireEvent('reached' + newPositionAtExtremity,{axis:axis});}}_scrollAtExtremity[axis] = newPositionAtExtremity;} // Update the recorded position if there's no duration\n\tif(!animationDuration){_lastScrollPosition[axis] = position;}}; /**\n\t\t\t * Retrieve the current position as an object with scrollLeft and scrollTop\n\t\t\t * properties.\n\t\t\t */_getPosition = function _getPosition(){return {scrollLeft:-_lastScrollPosition.x,scrollTop:-_lastScrollPosition.y};};_scheduleAxisPosition = function _scheduleAxisPosition(axis,position,animationDuration,animationBezier,afterDelay){_timeouts.push(setTimeout(function(){_setAxisPosition(axis,position,animationDuration,animationBezier);},afterDelay));};_fireEvent = function _fireEvent(eventName,eventObject){var i,l;eventObject.srcObject = _publicSelf; // Iterate through any listeners\n\tfor(i = 0,l = _eventListeners[eventName].length;i < l;i = i + 1) { // Execute each in a try/catch\n\ttry{_eventListeners[eventName][i](eventObject);}catch(error) {if(window.console && window.console.error){if(error.message){window.console.error(error.message + ' (' + error.sourceURL + ', line ' + error.line + ')');}else {window.console.error('Error encountered executing FTScroller event listener callback for [' + eventName + ']. Add a \"debugger\" statement here to obtain a full backtrace.');if(window.console.dir)window.console.dir(error);}}}}}; /**\n\t\t\t * Update the scroll position so that the child element is in view.\n\t\t\t */_childFocused = function _childFocused(event){var offset,axis,visibleChildPortion;var focusedNodeRect=_getBoundingRect(event.target);var containerRect=_getBoundingRect(_containerNode);var edgeMap={x:'left',y:'top'};var opEdgeMap={x:'right',y:'bottom'};var dimensionMap={x:'width',y:'height'}; // If an input is currently being tracked, ignore the focus event\n\tif(_inputIdentifier !== false){return;}for(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis)){ // If the focussed node is entirely in view, there is no need to center it\n\tif(focusedNodeRect[edgeMap[axis]] >= containerRect[edgeMap[axis]] && focusedNodeRect[opEdgeMap[axis]] <= containerRect[opEdgeMap[axis]]){continue;} // If the focussed node is larger than the container...\n\tif(focusedNodeRect[dimensionMap[axis]] > containerRect[dimensionMap[axis]]){visibleChildPortion = focusedNodeRect[dimensionMap[axis]] - Math.max(0,containerRect[edgeMap[axis]] - focusedNodeRect[edgeMap[axis]]) - Math.max(0,focusedNodeRect[opEdgeMap[axis]] - containerRect[opEdgeMap[axis]]); // If more than half a container's portion of the focussed node is visible, there's no need to center it\n\tif(visibleChildPortion >= containerRect[dimensionMap[axis]] / 2){continue;}} // Set the target offset to be in the middle of the container, or as close as bounds permit\n\toffset = -Math.round(focusedNodeRect[dimensionMap[axis]] / 2 - _lastScrollPosition[axis] + focusedNodeRect[edgeMap[axis]] - containerRect[edgeMap[axis]] - containerRect[dimensionMap[axis]] / 2);offset = Math.min(0,Math.max(_metrics.scrollEnd[axis],offset)); // Perform the scroll\n\t_setAxisPosition(axis,offset,0);_baseScrollPosition[axis] = offset;}}_fireEvent('scroll',_getPosition());}; /**\n\t\t\t * Given a relative distance beyond the element bounds, returns a modified version to\n\t\t\t * simulate bouncy/springy edges.\n\t\t\t */_modifyDistanceBeyondBounds = function _modifyDistanceBeyondBounds(distance,axis){if(!_instanceOptions.bouncing){return 0;}var e=Math.exp(distance / _metrics.container[axis]);return Math.round(_metrics.container[axis] * 0.6 * (e - 1) / (e + 1));}; /**\n\t\t\t * Given positions for each enabled axis, returns an object showing how far each axis is beyond\n\t\t\t * bounds. If within bounds, -1 is returned; if at the bounds, 0 is returned.\n\t\t\t */_distancesBeyondBounds = function _distancesBeyondBounds(positions){var axis,position;var distances={};for(axis in positions) {if(positions.hasOwnProperty(axis)){position = positions[axis]; // If the position is to the left/top, no further modification required\n\tif(position >= 0){distances[axis] = position; // If it's within the bounds, use -1\n\t}else if(position > _metrics.scrollEnd[axis]){distances[axis] = -1; // Otherwise, amend by the distance of the maximum edge\n\t}else {distances[axis] = _metrics.scrollEnd[axis] - position;}}}return distances;}; /**\n\t\t\t * On platforms which support it, use RequestAnimationFrame to group\n\t\t\t * position updates for speed.  Starts the render process.\n\t\t\t */_startAnimation = function _startAnimation(){if(_reqAnimationFrame){_cancelAnimation();_animationFrameRequest = _reqAnimationFrame(_scheduleRender);}}; /**\n\t\t\t * On platforms which support RequestAnimationFrame, provide the rendering loop.\n\t\t\t * Takes two arguments; the first is the render/position update function to\n\t\t\t * be called, and the second is a string controlling the render type to\n\t\t\t * allow previous changes to be cancelled - should be 'pan' or 'scroll'.\n\t\t\t */_scheduleRender = function _scheduleRender(){var axis,positionUpdated; // If using requestAnimationFrame schedule the next update at once\n\tif(_reqAnimationFrame){_animationFrameRequest = _reqAnimationFrame(_scheduleRender);} // Perform the draw.\n\tfor(axis in _scrollableAxes) {if(_scrollableAxes.hasOwnProperty(axis) && _targetScrollPosition[axis] !== _lastScrollPosition[axis]){_setAxisPosition(axis,_targetScrollPosition[axis]);positionUpdated = true;}} // If full, locked scrolling has enabled, fire any scroll and segment change events\n\tif(_isScrolling && positionUpdated){_fireEvent('scroll',_getPosition());_updateSegments(false);}}; /**\n\t\t\t * Stops the animation process.\n\t\t\t */_cancelAnimation = function _cancelAnimation(){if(_animationFrameRequest === false || !_cancelAnimationFrame){return;}_cancelAnimationFrame(_animationFrameRequest);_animationFrameRequest = false;}; /**\n\t\t\t * Remove then re-set event handlers\n\t\t\t */_resetEventHandlers = function(){_removeEventHandlers();_addEventHandlers();}; /**\n\t\t\t * Register event handlers\n\t\t\t */_addEventHandlers = function _addEventHandlers(){var MutationObserver; // Only remove the event if the node exists (DOM elements can go away)\n\tif(!_containerNode){return;}if(_trackPointerEvents && !_instanceOptions.disabledInputMethods.pointer){if(_pointerEventsPrefixed){_containerNode.addEventListener('MSPointerDown',_onPointerDown);_containerNode.addEventListener('MSPointerMove',_onPointerMove);_containerNode.addEventListener('MSPointerUp',_onPointerUp);_containerNode.addEventListener('MSPointerCancel',_onPointerCancel);}else {_containerNode.addEventListener('pointerdown',_onPointerDown);_containerNode.addEventListener('pointermove',_onPointerMove);_containerNode.addEventListener('pointerup',_onPointerUp);_containerNode.addEventListener('pointercancel',_onPointerCancel);}}else {if(_trackTouchEvents && !_instanceOptions.disabledInputMethods.touch){_containerNode.addEventListener('touchstart',_onTouchStart);_containerNode.addEventListener('touchmove',_onTouchMove);_containerNode.addEventListener('touchend',_onTouchEnd);_containerNode.addEventListener('touchcancel',_onTouchEnd);}if(!_instanceOptions.disabledInputMethods.mouse){_containerNode.addEventListener('mousedown',_onMouseDown);}}if(!_instanceOptions.disabledInputMethods.scroll){_containerNode.addEventListener('DOMMouseScroll',_onMouseScroll);_containerNode.addEventListener('mousewheel',_onMouseScroll);} // If any of the input methods which would eventually trigger a click are\n\t// enabled, add a click event listener so that phantom clicks can be prevented\n\t// at the end of a scroll. Otherwise, don't add a listener and don't prevent\n\t// clicks.\n\tif(!_instanceOptions.disabledInputMethods.mouse || !_instanceOptions.disabledInputMethods.touch || !_instanceOptions.disabledInputMethods.pointer){ // Add a click listener.  On IE, add the listener to the document, to allow\n\t// clicks to be cancelled if a scroll ends outside the bounds of the container; on\n\t// other platforms, add to the container node.\n\tif(_trackPointerEvents){document.addEventListener('click',_onClick,true);}else {_containerNode.addEventListener('click',_onClick,true);}} // Watch for changes inside the contained element to update bounds - de-bounced slightly.\n\tif(!_instanceOptions.disabledInputMethods.focus){_contentParentNode.addEventListener('focus',_childFocused);}if(_instanceOptions.updateOnChanges){ // Try and reuse the old, disconnected observer instance if available\n\t// Otherwise, check for support before proceeding\n\tif(!_mutationObserver){MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window[_vendorStylePropertyPrefix + 'MutationObserver'];if(MutationObserver){_mutationObserver = new MutationObserver(_domChanged);}}if(_mutationObserver){_mutationObserver.observe(_contentParentNode,{childList:true,characterData:true,subtree:true});}else {_contentParentNode.addEventListener('DOMSubtreeModified',function(e){ // Ignore changes to nested FT Scrollers - even updating a transform style\n\t// can trigger a DOMSubtreeModified in IE, causing nested scrollers to always\n\t// favour the deepest scroller as parent scrollers 'resize'/end scrolling.\n\tif(e && (e.srcElement === _contentParentNode || e.srcElement.className.indexOf('ftscroller_') !== -1)){return;}_domChanged();},true);}_contentParentNode.addEventListener('load',_domChanged);}if(_instanceOptions.updateOnWindowResize){window.addEventListener('resize',_domChanged);}}; /**\n\t\t\t * Remove event handlers.\n\t\t\t *\n\t\t\t * The current flags may not match the state when the event handlers were set up,\n\t\t\t * so remove all event handlers unconditionally, just in case they're bound.\n\t\t\t */_removeEventHandlers = function _removeEventHandlers(){if(_containerNode){_containerNode.removeEventListener('MSPointerDown',_onPointerDown);_containerNode.removeEventListener('MSPointerMove',_onPointerMove);_containerNode.removeEventListener('MSPointerUp',_onPointerUp);_containerNode.removeEventListener('MSPointerCancel',_onPointerCancel);_containerNode.removeEventListener('pointerdown',_onPointerDown);_containerNode.removeEventListener('pointermove',_onPointerMove);_containerNode.removeEventListener('pointerup',_onPointerUp);_containerNode.removeEventListener('pointercancel',_onPointerCancel);_containerNode.removeEventListener('touchstart',_onTouchStart);_containerNode.removeEventListener('touchmove',_onTouchMove);_containerNode.removeEventListener('touchend',_onTouchEnd);_containerNode.removeEventListener('touchcancel',_onTouchEnd);_containerNode.removeEventListener('mousedown',_onMouseDown);_containerNode.removeEventListener('DOMMouseScroll',_onMouseScroll);_containerNode.removeEventListener('mousewheel',_onMouseScroll);_containerNode.removeEventListener('click',_onClick,true);}if(_contentParentNode){_contentParentNode.removeEventListener('focus',_childFocused);_contentParentNode.removeEventListener('DOMSubtreeModified',_domChanged);_contentParentNode.removeEventListener('load',_domChanged);}if(_mutationObserver){_mutationObserver.disconnect();}document.removeEventListener('mousemove',_onMouseMove);document.removeEventListener('mouseup',_onMouseUp);document.removeEventListener('click',_onClick,true);window.removeEventListener('resize',_domChanged);}; /**\n\t\t\t * Touch event handlers\n\t\t\t */_onTouchStart = function _onTouchStart(startEvent){var i,l,touchEvent; // If a touch is already active, ensure that the index\n\t// is mapped to the correct finger, and return.\n\tif(_inputIdentifier){for(i = 0,l = startEvent.touches.length;i < l;i = i + 1) {if(startEvent.touches[i].identifier === _inputIdentifier){_inputIndex = i;}}return;} // Track the new touch's identifier, reset index, and pass\n\t// the coordinates to the scroll start function.\n\ttouchEvent = startEvent.touches[0];_inputIdentifier = touchEvent.identifier;_inputIndex = 0;_startScroll(touchEvent.clientX,touchEvent.clientY,startEvent.timeStamp,startEvent);};_onTouchMove = function _onTouchMove(moveEvent){if(_inputIdentifier === false){return;} // Get the coordinates from the appropriate touch event and\n\t// pass them on to the scroll handler\n\tvar touchEvent=moveEvent.touches[_inputIndex];_updateScroll(touchEvent.clientX,touchEvent.clientY,moveEvent.timeStamp,moveEvent);};_onTouchEnd = function _onTouchEnd(endEvent){var i,l; // Check whether the original touch event is still active,\n\t// if it is, update the index and return.\n\tif(endEvent.touches){for(i = 0,l = endEvent.touches.length;i < l;i = i + 1) {if(endEvent.touches[i].identifier === _inputIdentifier){_inputIndex = i;return;}}} // Complete the scroll.  Note that touch end events\n\t// don't capture coordinates.\n\t_endScroll(endEvent.timeStamp,endEvent);}; /**\n\t\t\t * Mouse event handlers\n\t\t\t */_onMouseDown = function _onMouseDown(startEvent){ // Don't track the right mouse buttons, or a context menu\n\tif(startEvent.button && startEvent.button === 2 || startEvent.ctrlKey){return;} // Capture if possible\n\tif(_containerNode.setCapture){_containerNode.setCapture();} // Add move & up handlers to the *document* to allow handling outside the element\n\tdocument.addEventListener('mousemove',_onMouseMove,true);document.addEventListener('mouseup',_onMouseUp,true);_inputIdentifier = startEvent.button || 1;_inputIndex = 0;_startScroll(startEvent.clientX,startEvent.clientY,startEvent.timeStamp,startEvent);};_onMouseMove = function _onMouseMove(moveEvent){if(!_inputIdentifier){return;}_updateScroll(moveEvent.clientX,moveEvent.clientY,moveEvent.timeStamp,moveEvent);};_onMouseUp = function _onMouseUp(endEvent){if(endEvent.button && endEvent.button !== _inputIdentifier){return;}document.removeEventListener('mousemove',_onMouseMove,true);document.removeEventListener('mouseup',_onMouseUp,true); // Release capture if possible\n\tif(_containerNode.releaseCapture){_containerNode.releaseCapture();}_endScroll(endEvent.timeStamp,endEvent);}; /**\n\t\t\t * Pointer event handlers\n\t\t\t */_onPointerDown = function _onPointerDown(startEvent){ // If there is already a pointer event being tracked, ignore subsequent.\n\t// However, if this pointer is seen as the primary pointer, override that.\n\tif(_inputIdentifier && !startEvent.isPrimary){return;} // Disable specific input types if specified in the config.  Separate\n\t// out touch and other events (eg treat both pen and mouse as \"mouse\")\n\tif(startEvent.pointerType === _pointerTypeTouch){if(_instanceOptions.disabledInputMethods.touch){return;}}else if(_instanceOptions.disabledInputMethods.mouse){return;}_inputIdentifier = startEvent.pointerId;_startScroll(startEvent.clientX,startEvent.clientY,startEvent.timeStamp,startEvent);};_onPointerMove = function _onPointerMove(moveEvent){if(_inputIdentifier !== moveEvent.pointerId){return;}_updateScroll(moveEvent.clientX,moveEvent.clientY,moveEvent.timeStamp,moveEvent);};_onPointerUp = function _onPointerUp(endEvent){if(_inputIdentifier !== endEvent.pointerId){return;}_endScroll(endEvent.timeStamp,endEvent);};_onPointerCancel = function _onPointerCancel(endEvent){_endScroll(endEvent.timeStamp,endEvent);};_onPointerCaptureEnd = function _onPointerCaptureEnd(event){ // On pointer capture end - which can happen because of another element\n\t// releasing pointer capture - don't end scrolling, but do track that\n\t// input capture has been lost.  This will result in pointers leaving\n\t// the window possibly being lost, but further interactions will fix\n\t// the tracking again.\n\t_inputCaptured = false;}; /**\n\t\t\t * Prevents click actions if appropriate\n\t\t\t */_onClick = function _onClick(clickEvent){ // If a scroll action hasn't resulted in the next scroll being prevented, and a scroll\n\t// isn't currently in progress with a different identifier, allow the click\n\tif(!_preventClick){return true;} // Prevent clicks using the preventDefault() and stopPropagation() handlers on the event;\n\t// this is safe even in IE10 as this is always a \"true\" event, never a window.event.\n\tclickEvent.preventDefault();clickEvent.stopPropagation();if(!_inputIdentifier){_preventClick = false;}return false;}; /**\n\t\t\t * Process scroll wheel/input actions as scroller scrolls\n\t\t\t */_onMouseScroll = function _onMouseScroll(event){var scrollDeltaX,scrollDeltaY;if(_inputIdentifier !== 'scrollwheel'){if(_inputIdentifier !== false){return true;}_inputIdentifier = 'scrollwheel';_cumulativeScroll.x = 0;_cumulativeScroll.y = 0; // Start a scroll event\n\tif(!_startScroll(event.clientX,event.clientY,Date.now(),event)){return;}} // Convert the scrollwheel values to a scroll value\n\tif(event.wheelDelta){if(event.wheelDeltaX){scrollDeltaX = event.wheelDeltaX / 2;scrollDeltaY = event.wheelDeltaY / 2;}else {scrollDeltaX = 0;scrollDeltaY = event.wheelDelta / 2;}}else {if(event.axis && event.axis === event.HORIZONTAL_AXIS){scrollDeltaX = event.detail * -10;scrollDeltaY = 0;}else {scrollDeltaX = 0;scrollDeltaY = event.detail * -10;}} // If the scroller is constrained to an x axis, convert y scroll to allow single-axis scroll\n\t// wheels to scroll constrained content.\n\tif(_instanceOptions.invertScrollWheel && !_instanceOptions.scrollingY && !scrollDeltaX){scrollDeltaX = scrollDeltaY;scrollDeltaY = 0;}_cumulativeScroll.x = Math.round(_cumulativeScroll.x + scrollDeltaX);_cumulativeScroll.y = Math.round(_cumulativeScroll.y + scrollDeltaY);_updateScroll(_gestureStart.x + _cumulativeScroll.x,_gestureStart.y + _cumulativeScroll.y,event.timeStamp,event); // End scrolling state\n\tif(_scrollWheelEndDebouncer){clearTimeout(_scrollWheelEndDebouncer);}_scrollWheelEndDebouncer = setTimeout(function(){_releaseInputCapture();_inputIdentifier = false;_isScrolling = false;_preventClick = false;_isDisplayingScroll = false;_ftscrollerMoving = false;if(_instanceOptions.windowScrollingActiveFlag){window[_instanceOptions.windowScrollingActiveFlag] = false;}_cancelAnimation();if(!_snapScroll()){_finalizeScroll();}},300);}; /**\n\t\t\t * Capture and release input support, particularly allowing tracking\n\t\t\t * of Metro pointers outside the docked view.  Note that _releaseInputCapture\n\t\t\t * should be called before the input identifier is cleared.\n\t\t\t */_captureInput = function _captureInput(){if(_inputCaptured || _inputIdentifier === false || _inputIdentifier === 'scrollwheel'){return;}if(_trackPointerEvents){_containerNode[_setPointerCapture](_inputIdentifier);_containerNode.addEventListener(_lostPointerCapture,_onPointerCaptureEnd,false);}_inputCaptured = true;};_releaseInputCapture = function _releaseInputCapture(){if(!_inputCaptured){return;}if(_trackPointerEvents){_containerNode.removeEventListener(_lostPointerCapture,_onPointerCaptureEnd,false);_containerNode[_releasePointerCapture](_inputIdentifier);}_inputCaptured = false;}; /**\n\t\t\t * Utility function acting as a getBoundingClientRect polyfill.\n\t\t\t */_getBoundingRect = function _getBoundingRect(anElement){if(anElement.getBoundingClientRect){return anElement.getBoundingClientRect();}var x=0,y=0,eachElement=anElement;while(eachElement) {x = x + eachElement.offsetLeft - eachElement.scrollLeft;y = y + eachElement.offsetTop - eachElement.scrollTop;eachElement = eachElement.offsetParent;}return {left:x,top:y,width:anElement.offsetWidth,height:anElement.offsetHeight};}; /*                     Instantiation                     */ // Set up the DOM node if appropriate\n\t_initializeDOM(); // Update sizes\n\t_updateDimensions(); // Set up the event handlers\n\t_addEventHandlers(); // Define a public API to be returned at the bottom - this is the public-facing interface.\n\t_publicSelf = {destroy:destroy,setSnapSize:setSnapSize,scrollTo:scrollTo,scrollBy:scrollBy,updateDimensions:updateDimensions,addEventListener:addEventListener,removeEventListener:removeEventListener,setDisabledInputMethods:setDisabledInputMethods};if(Object.defineProperties){Object.defineProperties(_publicSelf,{'scrollHeight':{get:function get(){return _metrics.content.y;},set:function set(value){throw new SyntaxError('scrollHeight is currently read-only - ignoring ' + value);}},'scrollLeft':{get:function get(){return -_lastScrollPosition.x;},set:function set(value){scrollTo(value,false,false);return -_lastScrollPosition.x;}},'scrollTop':{get:function get(){return -_lastScrollPosition.y;},set:function set(value){scrollTo(false,value,false);return -_lastScrollPosition.y;}},'scrollWidth':{get:function get(){return _metrics.content.x;},set:function set(value){throw new SyntaxError('scrollWidth is currently read-only - ignoring ' + value);}},'segmentCount':{get:function get(){if(!_instanceOptions.snapping){return {x:NaN,y:NaN};}return {x:Math.ceil(_metrics.content.x / _snapGridSize.x),y:Math.ceil(_metrics.content.y / _snapGridSize.y)};},set:function set(value){throw new SyntaxError('segmentCount is currently read-only - ignoring ' + value);}},'currentSegment':{get:function get(){return {x:_activeSegment.x,y:_activeSegment.y};},set:function set(value){throw new SyntaxError('currentSegment is currently read-only - ignoring ' + value);}},'contentContainerNode':{get:function get(){return _contentParentNode;},set:function set(value){throw new SyntaxError('contentContainerNode is currently read-only - ignoring ' + value);}}});} // Return the public interface.\n\treturn _publicSelf;}; /*          Prototype Functions and Properties           */ /**\n\t\t * The HTML to prepend to the scrollable content to wrap it. Used internally,\n\t\t * and may be used to pre-wrap scrollable content.  Axes can optionally\n\t\t * be excluded for speed improvements.\n\t\t */FTScroller.prototype.getPrependedHTML = function(excludeXAxis,excludeYAxis,hwAccelerationClass){if(!hwAccelerationClass){if(typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass){hwAccelerationClass = FTScrollerOptions.hwAccelerationClass;}else {hwAccelerationClass = 'ftscroller_hwaccelerated';}}var output='<div class=\"ftscroller_container\">';if(!excludeXAxis){output += '<div class=\"ftscroller_x ' + hwAccelerationClass + '\">';}if(!excludeYAxis){output += '<div class=\"ftscroller_y ' + hwAccelerationClass + '\">';}return output;}; /**\n\t\t * The HTML to append to the scrollable content to wrap it; again, used internally,\n\t\t * and may be used to pre-wrap scrollable content.\n\t\t */FTScroller.prototype.getAppendedHTML = function(excludeXAxis,excludeYAxis,hwAccelerationClass,scrollbars){if(!hwAccelerationClass){if(typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass){hwAccelerationClass = FTScrollerOptions.hwAccelerationClass;}else {hwAccelerationClass = 'ftscroller_hwaccelerated';}}var output='';if(!excludeXAxis){output += '</div>';}if(!excludeYAxis){output += '</div>';}if(scrollbars){if(!excludeXAxis){output += '<div class=\"ftscroller_scrollbar ftscroller_scrollbarx ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';}if(!excludeYAxis){output += '<div class=\"ftscroller_scrollbar ftscroller_scrollbary ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';}}output += '</div>';return output;};})();(function(){'use strict';function clamp(value){if(value > 1.0)return 1.0;if(value < 0.0)return 0.0;return value;} /**\n\t\t * Represents a two-dimensional cubic bezier curve with the starting\n\t\t * point (0, 0) and the end point (1, 1). The two control points p1 and p2\n\t\t * have x and y coordinates between 0 and 1.\n\t\t *\n\t\t * This type of bezier curves can be used as CSS transform timing functions.\n\t\t */CubicBezier = function(p1x,p1y,p2x,p2y){ // Control points\n\tthis._p1 = {x:clamp(p1x),y:clamp(p1y)};this._p2 = {x:clamp(p2x),y:clamp(p2y)};};CubicBezier.prototype._getCoordinateForT = function(t,p1,p2){var c=3 * p1,b=3 * (p2 - p1) - c,a=1 - c - b;return ((a * t + b) * t + c) * t;};CubicBezier.prototype._getCoordinateDerivateForT = function(t,p1,p2){var c=3 * p1,b=3 * (p2 - p1) - c,a=1 - c - b;return (3 * a * t + 2 * b) * t + c;};CubicBezier.prototype._getTForCoordinate = function(c,p1,p2,epsilon){if(!isFinite(epsilon) || epsilon <= 0){throw new RangeError('\"epsilon\" must be a number greater than 0.');}var t2,i,c2,d2; // First try a few iterations of Newton's method -- normally very fast.\n\tfor(t2 = c,i = 0;i < 8;i = i + 1) {c2 = this._getCoordinateForT(t2,p1,p2) - c;if(Math.abs(c2) < epsilon){return t2;}d2 = this._getCoordinateDerivateForT(t2,p1,p2);if(Math.abs(d2) < 1e-6){break;}t2 = t2 - c2 / d2;} // Fall back to the bisection method for reliability.\n\tt2 = c;var t0=0,t1=1;if(t2 < t0){return t0;}if(t2 > t1){return t1;}while(t0 < t1) {c2 = this._getCoordinateForT(t2,p1,p2);if(Math.abs(c2 - c) < epsilon){return t2;}if(c > c2){t0 = t2;}else {t1 = t2;}t2 = (t1 - t0) * 0.5 + t0;} // Failure.\n\treturn t2;}; /**\n\t\t * Computes the point for a given t value.\n\t\t *\n\t\t * @param {number} t\n\t\t * @returns {Object} Returns an object with x and y properties\n\t\t */CubicBezier.prototype.getPointForT = function(t){ // Special cases: starting and ending points\n\tif(t === 0 || t === 1){return {x:t,y:t};} // Check for correct t value (must be between 0 and 1)\n\tif(t < 0 || t > 1){_throwRangeError('t',t);}return {x:this._getCoordinateForT(t,this._p1.x,this._p2.x),y:this._getCoordinateForT(t,this._p1.y,this._p2.y)};};CubicBezier.prototype.getTForX = function(x,epsilon){return this._getTForCoordinate(x,this._p1.x,this._p2.x,epsilon);};CubicBezier.prototype.getTForY = function(y,epsilon){return this._getTForCoordinate(y,this._p1.y,this._p2.y,epsilon);}; /**\n\t\t * Computes auxiliary points using De Casteljau's algorithm.\n\t\t *\n\t\t * @param {number} t must be greater than 0 and lower than 1.\n\t\t * @returns {Object} with members i0, i1, i2 (first iteration),\n\t\t *    j1, j2 (second iteration) and k (the exact point for t)\n\t\t */CubicBezier.prototype._getAuxPoints = function(t){if(t <= 0 || t >= 1){_throwRangeError('t',t);} /* First series of auxiliary points */ // First control point of the left curve\n\tvar i0={x:t * this._p1.x,y:t * this._p1.y},i1={x:this._p1.x + t * (this._p2.x - this._p1.x),y:this._p1.y + t * (this._p2.y - this._p1.y)}, // Second control point of the right curve\n\ti2={x:this._p2.x + t * (1 - this._p2.x),y:this._p2.y + t * (1 - this._p2.y)}; /* Second series of auxiliary points */ // Second control point of the left curve\n\tvar j0={x:i0.x + t * (i1.x - i0.x),y:i0.y + t * (i1.y - i0.y)}, // First control point of the right curve\n\tj1={x:i1.x + t * (i2.x - i1.x),y:i1.y + t * (i2.y - i1.y)}; // The division point (ending point of left curve, starting point of right curve)\n\tvar k={x:j0.x + t * (j1.x - j0.x),y:j0.y + t * (j1.y - j0.y)};return {i0:i0,i1:i1,i2:i2,j0:j0,j1:j1,k:k};}; /**\n\t\t * Divides the bezier curve into two bezier functions.\n\t\t *\n\t\t * De Casteljau's algorithm is used to compute the new starting, ending, and\n\t\t * control points.\n\t\t *\n\t\t * @param {number} t must be greater than 0 and lower than 1.\n\t\t *     t === 1 or t === 0 are the starting/ending points of the curve, so no\n\t\t *     division is needed.\n\t\t *\n\t\t * @returns {CubicBezier[]} Returns an array containing two bezier curves\n\t\t *     to the left and the right of t.\n\t\t */CubicBezier.prototype.divideAtT = function(t){if(t < 0 || t > 1){_throwRangeError('t',t);} // Special cases t = 0, t = 1: Curve can be cloned for one side, the other\n\t// side is a linear curve (with duration 0)\n\tif(t === 0 || t === 1){var curves=[];curves[t] = CubicBezier.linear();curves[1 - t] = this.clone();return curves;}var left={},right={},points=this._getAuxPoints(t);var i0=points.i0,i2=points.i2,j0=points.j0,j1=points.j1,k=points.k; // Normalize derived points, so that the new curves starting/ending point\n\t// coordinates are (0, 0) respectively (1, 1)\n\tvar factorX=k.x,factorY=k.y;left.p1 = {x:i0.x / factorX,y:i0.y / factorY};left.p2 = {x:j0.x / factorX,y:j0.y / factorY};right.p1 = {x:(j1.x - factorX) / (1 - factorX),y:(j1.y - factorY) / (1 - factorY)};right.p2 = {x:(i2.x - factorX) / (1 - factorX),y:(i2.y - factorY) / (1 - factorY)};return [new CubicBezier(left.p1.x,left.p1.y,left.p2.x,left.p2.y),new CubicBezier(right.p1.x,right.p1.y,right.p2.x,right.p2.y)];};CubicBezier.prototype.divideAtX = function(x,epsilon){if(x < 0 || x > 1){_throwRangeError('x',x);}var t=this.getTForX(x,epsilon);return this.divideAtT(t);};CubicBezier.prototype.divideAtY = function(y,epsilon){if(y < 0 || y > 1){_throwRangeError('y',y);}var t=this.getTForY(y,epsilon);return this.divideAtT(t);};CubicBezier.prototype.clone = function(){return new CubicBezier(this._p1.x,this._p1.y,this._p2.x,this._p2.y);};CubicBezier.prototype.toString = function(){return \"cubic-bezier(\" + [this._p1.x,this._p1.y,this._p2.x,this._p2.y].join(\", \") + \")\";};CubicBezier.linear = function(){return new CubicBezier();};CubicBezier.ease = function(){return new CubicBezier(0.25,0.1,0.25,1.0);};CubicBezier.linear = function(){return new CubicBezier(0.0,0.0,1.0,1.0);};CubicBezier.easeIn = function(){return new CubicBezier(0.42,0,1.0,1.0);};CubicBezier.easeOut = function(){return new CubicBezier(0,0,0.58,1.0);};CubicBezier.easeInOut = function(){return new CubicBezier(0.42,0,0.58,1.0);};})();if(typeof define !== 'undefined' && define.amd){ // AMD. Register as an anonymous module.\n\tdefine(function(){'use strict';return {FTScroller:FTScroller,CubicBezier:CubicBezier};});}else if(typeof module !== 'undefined' && module.exports){module.exports = function(domNode,options){'use strict';return new FTScroller(domNode,options);};module.exports.FTScroller = FTScroller;module.exports.CubicBezier = CubicBezier;}\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t\"use strict\";\n\t\n\tvar define = false;\n\t\n\t'use strict';\n\t\n\t/*global exports*/\n\tfunction emptyElement(targetEl) {\n\t\tfor (var i = 0; i < targetEl.children.length; i++) {\n\t\t\ttargetEl.removeChild(targetEl.children[i]);\n\t\t}\n\t}\n\t\n\tfunction createElement(nodeName, content, classes) {\n\t\tvar el = document.createElement(nodeName);\n\t\tel.innerHTML = content;\n\t\tel.setAttribute(\"class\", classes);\n\t\treturn el;\n\t}\n\t\n\tfunction wrapElement(targetEl, wrapEl) {\n\t\tvar parentEl = targetEl.parentNode;\n\t\twrapEl.appendChild(targetEl);\n\t\tparentEl.appendChild(wrapEl);\n\t}\n\t\n\tfunction unwrapElement(targetEl) {\n\t\tvar wrappingEl = targetEl.parentNode;\n\t\tvar wrappingElParent = wrappingEl.parentNode;\n\t\twhile (wrappingEl.childNodes.length > 0) {\n\t\t\twrappingElParent.appendChild(wrappingEl.childNodes[0]);\n\t\t}\n\t\twrappingElParent.removeChild(wrappingEl);\n\t}\n\t\n\tfunction createItemsList(containerEl) {\n\t\tvar itemsList = createElement(\"ol\", \"\", \"o-gallery__items\");\n\t\tcontainerEl.appendChild(itemsList);\n\t\treturn itemsList;\n\t}\n\t\n\tfunction createItems(containerEl, items) {\n\t\tvar itemEl;\n\t\tvar itemEls = [];\n\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\titemEl = createElement(\"li\", \"&nbsp;\", \"o-gallery__item\");\n\t\t\tif (items[i].selected) {\n\t\t\t\titemEl.setAttribute('aria-selected', 'true');\n\t\t\t}\n\t\t\tcontainerEl.appendChild(itemEl);\n\t\t\titemEls.push(itemEl);\n\t\t}\n\t\treturn itemEls;\n\t}\n\t\n\tfunction insertItemContent(config, item, itemEl) {\n\t\temptyElement(itemEl);\n\t\tvar contentEl = createElement(\"div\", item.content, \"o-gallery__item__content\");\n\t\titemEl.appendChild(contentEl);\n\t\tif (config.captions) {\n\t\t\tvar captionEl = createElement(\"div\", item.caption || \"\", \"o-gallery__item__caption\");\n\t\t\titemEl.appendChild(captionEl);\n\t\t}\n\t}\n\t\n\tfunction setPropertyIfAttributeExists(obj, propName, el, attrName) {\n\t\tvar v = el.getAttribute(attrName);\n\t\tif (v !== null) {\n\t\t\tif (v === \"true\") {\n\t\t\t\tv = true;\n\t\t\t} else if (v === \"false\") {\n\t\t\t\tv = false;\n\t\t\t}\n\t\t\tobj[propName] = v;\n\t\t}\n\t}\n\t\n\tfunction getPropertiesFromAttributes(el, map) {\n\t\tvar obj = {};\n\t\tvar prop;\n\t\tfor (prop in map) {\n\t\t\tif (map.hasOwnProperty(prop)) {\n\t\t\t\tsetPropertyIfAttributeExists(obj, prop, el, map[prop]);\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}\n\t\n\tfunction setAttributesFromProperties(el, obj, map, excl) {\n\t\tvar exclude = excl || [];\n\t\tfor (var prop in obj) {\n\t\t\tif (obj.hasOwnProperty(prop) && exclude.indexOf(prop) < 0) {\n\t\t\t\tel.setAttribute(map[prop], obj[prop]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\texports.emptyElement = emptyElement;\n\texports.createElement = createElement;\n\texports.wrapElement = wrapElement;\n\texports.unwrapElement = unwrapElement;\n\texports.createItemsList = createItemsList;\n\texports.createItems = createItems;\n\texports.insertItemContent = insertItemContent;\n\texports.setAttributesFromProperties = setAttributesFromProperties;\n\texports.getPropertiesFromAttributes = getPropertiesFromAttributes;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require,module */\n\t'use strict';\n\t\n\tvar galleryDom = __webpack_require__(23);\n\t\n\t/**\n\t * Mimics FTScroller without touch interface, transitions or events\n\t * Intended for IE8 or other browsers that lack support for CSS transitions\n\t */\n\tfunction SimpleScroller(containerEl) {\n\t\n\t\tvar scroller = this;\n\t\tvar allItemsEl;\n\t\tvar viewportEl;\n\t\n\t\tfunction updateDimensions() {\n\t\t\tscroller.scrollLeft = viewportEl.scrollLeft;\n\t\t}\n\t\n\t\tfunction scrollTo(n) {\n\t\t\tviewportEl.scrollLeft = n;\n\t\t\tupdateDimensions();\n\t\t\tcontainerEl.dispatchEvent(new CustomEvent('scrollend', {\n\t\t\t\tx: n\n\t\t\t}));\n\t\t}\n\t\n\t\tfunction destroy() {\n\t\t\tif (containerEl.querySelector('.o-gallery__viewport')) {\n\t\t\t\tgalleryDom.unwrapElement(allItemsEl);\n\t\t\t}\n\t\t}\n\t\n\t\tallItemsEl = containerEl.querySelector('.o-gallery__items');\n\t\tviewportEl = galleryDom.createElement('div', '', 'o-gallery__viewport');\n\t\tgalleryDom.wrapElement(allItemsEl, viewportEl);\n\t\tupdateDimensions();\n\t\n\t\tthis.contentContainerNode = allItemsEl;\n\t\tthis.scrollTo = scrollTo;\n\t\tthis.updateDimensions = updateDimensions;\n\t\tthis.destroy = destroy;\n\t}\n\t\n\tmodule.exports = SimpleScroller;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(26);\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require, module*/\n\t\n\tvar Tabs = __webpack_require__(27);\n\t\n\tvar constructAll = function constructAll() {\n\t\tTabs.init();\n\t\tdocument.removeEventListener('o.DOMContentLoaded', constructAll);\n\t};\n\t\n\tdocument.addEventListener('o.DOMContentLoaded', constructAll);\n\t\n\tmodule.exports = Tabs;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar define = false;\n\t\n\t/*global module, require*/\n\tvar oDom = __webpack_require__(16);\n\t\n\tvar Tabs = (function () {\n\t\tfunction Tabs(rootEl, config) {\n\t\t\t_classCallCheck(this, Tabs);\n\t\n\t\t\tthis.rootEl = rootEl;\n\t\t\tthis.rootEl.setAttribute('data-o-tabs--js', '');\n\t\n\t\t\tthis.updateUrl = rootEl.getAttribute('data-o-tabs-update-url') !== null;\n\t\t\tthis.selectedTabIndex = -1;\n\t\n\t\t\tthis.tabEls = this.rootEl.querySelectorAll('[role=tab]');\n\t\t\tthis.tabEls = [].slice.call(this.tabEls).filter(this.tabHasValidUrl);\n\t\t\tthis.tabpanelEls = this.getTabPanelEls(this.tabEls);\n\t\n\t\t\tthis.boundClickHandler = this.clickHandler.bind(this);\n\t\t\tthis.rootEl.addEventListener('click', this.boundClickHandler, false);\n\t\t\tthis.boundKeyPressHandler = this.keyPressHandler.bind(this);\n\t\t\tthis.rootEl.addEventListener('keypress', this.boundKeyPressHandler, false);\n\t\t\tthis.boundHashChangeHandler = this.hashChangeHandler.bind(this);\n\t\t\twindow.addEventListener('hashchange', this.boundHashChangeHandler, false);\n\t\n\t\t\tif (!config) {\n\t\t\t\tconfig = {};\n\t\t\t\tArray.prototype.forEach.call(this.rootEl.attributes, function (attr) {\n\t\t\t\t\tif (attr.name.includes('data-o-tabs')) {\n\t\t\t\t\t\t// Remove the unnecessary part of the string the first\n\t\t\t\t\t\t// time this is run for each attribute\n\t\t\t\t\t\tvar key = attr.name.replace('data-o-tabs-', '');\n\t\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// If it's a JSON, a boolean or a number, we want it stored like that,\n\t\t\t\t\t\t\t// and not as a string. We also replace all ' with \" so JSON strings\n\t\t\t\t\t\t\t// are parsed correctly\n\t\t\t\t\t\t\tconfig[key] = JSON.parse(attr.value.replace(/\\'/g, '\"'));\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconfig[key] = attr.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tthis.config = config;\n\t\t\tthis.dispatchCustomEvent('ready', {\n\t\t\t\ttabs: this\n\t\t\t});\n\t\t\tthis.selectTab(this.getSelectedTabIndex());\n\t\t}\n\t\n\t\t_createClass(Tabs, [{\n\t\t\tkey: 'getTabTargetId',\n\t\t\tvalue: function getTabTargetId(tabEl) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tvar linkEls = tabEl.getElementsByTagName('a');\n\t\t\t\treturn linkEls && linkEls[0] ? linkEls[0].getAttribute('href').replace('#', '') : '';\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTabPanelEls',\n\t\t\tvalue: function getTabPanelEls(tabEls) {\n\t\t\t\tvar panelEls = [];\n\t\n\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\tvar _didIteratorError = false;\n\t\t\t\tvar _iteratorError = undefined;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator = tabEls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\tvar tab = _step.value;\n\t\n\t\t\t\t\t\tvar tabTargetId = this.getTabTargetId(tab);\n\t\t\t\t\t\tvar targetEl = document.getElementById(tabTargetId);\n\t\n\t\t\t\t\t\tif (targetEl) {\n\t\t\t\t\t\t\ttab.setAttribute('aria-controls', tabTargetId);\n\t\t\t\t\t\t\ttab.setAttribute('tabindex', '0');\n\t\n\t\t\t\t\t\t\tvar label = tab.getElementsByTagName('a')[0];\n\t\t\t\t\t\t\tvar labelId = tabTargetId + '-label';\n\t\t\t\t\t\t\tlabel.setAttribute('tabindex', '-1');\n\t\t\t\t\t\t\tlabel.id = labelId;\n\t\t\t\t\t\t\ttargetEl.setAttribute('aria-labelledby', labelId);\n\t\t\t\t\t\t\ttargetEl.setAttribute('role', 'tabpanel');\n\t\t\t\t\t\t\ttargetEl.setAttribute('tabindex', '0');\n\t\t\t\t\t\t\tpanelEls.push(targetEl);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t_iteratorError = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator['return']) {\n\t\t\t\t\t\t\t_iterator['return']();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn panelEls;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTabElementFromHash',\n\t\t\tvalue: function getTabElementFromHash() {\n\t\t\t\tvar tabLink = this.rootEl.querySelector('[href=\"' + location.hash + '\"]');\n\t\t\t\treturn tabLink && tabLink.parentNode ? tabLink.parentNode : null;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTabIndexFromElement',\n\t\t\tvalue: function getTabIndexFromElement(el) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\treturn oDom.getIndex(el);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getSelectedTabElement',\n\t\t\tvalue: function getSelectedTabElement() {\n\t\t\t\treturn this.rootEl.querySelector('[aria-selected=true]');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getSelectedTabIndex',\n\t\t\tvalue: function getSelectedTabIndex() {\n\t\t\t\tvar selectedTabElement = this.updateUrl && location.hash ? this.getTabElementFromHash() : this.getSelectedTabElement();\n\t\t\t\treturn selectedTabElement ? this.getTabIndexFromElement(selectedTabElement) : 0;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'isValidTab',\n\t\t\tvalue: function isValidTab(index) {\n\t\t\t\treturn !isNaN(index) && index >= 0 && index < this.tabEls.length;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hidePanel',\n\t\t\tvalue: function hidePanel(panelEl) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tpanelEl.setAttribute('aria-expanded', 'false');\n\t\t\t\tpanelEl.setAttribute('aria-hidden', 'true');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'showPanel',\n\t\t\tvalue: function showPanel(panelEl, disableFocus) {\n\t\t\t\tpanelEl.setAttribute('aria-expanded', 'true');\n\t\t\t\tpanelEl.setAttribute('aria-hidden', 'false');\n\t\n\t\t\t\t// Remove the focus ring for sighted users\n\t\t\t\tpanelEl.style.outline = 0;\n\t\n\t\t\t\tif (disableFocus) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// update the url to match the selected tab\n\t\t\t\tif (panelEl.id && this.updateUrl) {\n\t\t\t\t\tlocation.href = '#' + panelEl.id;\n\t\t\t\t}\n\t\n\t\t\t\t// Get current scroll position\n\t\t\t\tvar x = window.scrollX || window.pageXOffset;\n\t\t\t\tvar y = window.scrollY || window.pageYOffset;\n\t\n\t\t\t\t// Give focus to the panel for screen readers\n\t\t\t\t// This might cause the browser to scroll up or down\n\t\t\t\tpanelEl.focus();\n\t\n\t\t\t\t// Scroll back to the original position\n\t\t\t\twindow.scrollTo(x, y);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'dispatchCustomEvent',\n\t\t\tvalue: function dispatchCustomEvent(event) {\n\t\t\t\tvar data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\t\t\tvar namespace = arguments.length <= 2 || arguments[2] === undefined ? 'oTabs' : arguments[2];\n\t\n\t\t\t\tthis.rootEl.dispatchEvent(new CustomEvent(namespace + '.' + event, {\n\t\t\t\t\tdetail: data,\n\t\t\t\t\tbubbles: true\n\t\t\t\t}));\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'selectTab',\n\t\t\tvalue: function selectTab(newIndex) {\n\t\t\t\tif (this.isValidTab(newIndex) && newIndex !== this.selectedTabIndex) {\n\t\t\t\t\tfor (var i = 0; i < this.tabEls.length; i++) {\n\t\t\t\t\t\tif (newIndex === i) {\n\t\t\t\t\t\t\tthis.tabEls[i].setAttribute('aria-selected', 'true');\n\t\t\t\t\t\t\tthis.showPanel(this.tabpanelEls[i], this.config.disablefocus);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.tabEls[i].setAttribute('aria-selected', 'false');\n\t\t\t\t\t\t\tthis.hidePanel(this.tabpanelEls[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.dispatchCustomEvent('tabSelect', {\n\t\t\t\t\t\ttabs: this,\n\t\t\t\t\t\tselected: newIndex,\n\t\t\t\t\t\tlastSelected: this.selectedTabIndex\n\t\t\t\t\t});\n\t\n\t\t\t\t\tthis.selectedTabIndex = newIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'clickHandler',\n\t\t\tvalue: function clickHandler(ev) {\n\t\t\t\tvar tabEl = oDom.getClosestMatch(ev.target, '[role=tab]');\n\t\n\t\t\t\tif (tabEl && this.tabHasValidUrl(tabEl)) {\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t\tthis.updateCurrentTab(tabEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'keyPressHandler',\n\t\t\tvalue: function keyPressHandler(ev) {\n\t\t\t\tvar tabEl = oDom.getClosestMatch(ev.target, '[role=tab]');\n\t\t\t\t// Only update if key pressed is enter key\n\t\t\t\tif (tabEl && ev.keyCode === 13 && this.tabHasValidUrl(tabEl)) {\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t\tthis.updateCurrentTab(tabEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hashChangeHandler',\n\t\t\tvalue: function hashChangeHandler() {\n\t\t\t\tif (!this.updateUrl) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar tabEl = this.getTabElementFromHash();\n\t\n\t\t\t\tif (tabEl) {\n\t\t\t\t\tthis.updateCurrentTab(tabEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'updateCurrentTab',\n\t\t\tvalue: function updateCurrentTab(tabEl) {\n\t\t\t\tvar index = this.getTabIndexFromElement(tabEl);\n\t\t\t\tthis.selectTab(index);\n\t\t\t\tthis.dispatchCustomEvent('event', {\n\t\t\t\t\tcategory: 'tabs',\n\t\t\t\t\taction: 'click',\n\t\t\t\t\ttab: tabEl.textContent.trim()\n\t\t\t\t}, 'oTracking');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'tabHasValidUrl',\n\t\t\tvalue: function tabHasValidUrl(tabEl) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tvar linkEls = tabEl.getElementsByTagName('a');\n\t\t\t\tif (!linkEls || !linkEls[0].hash) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn linkEls[0].pathname === location.pathname;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'destroy',\n\t\t\tvalue: function destroy() {\n\t\t\t\tthis.rootEl.removeEventListener('click', this.boundClickHandler, false);\n\t\t\t\tthis.rootEl.removeEventListener('keypress', this.boundKeyPressHandler, false);\n\t\t\t\twindow.removeEventListener('hashchange', this.boundHashChangeHandler, false);\n\t\t\t\tthis.rootEl.removeAttribute('data-o-tabs--js');\n\t\n\t\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\t\tvar _didIteratorError2 = false;\n\t\t\t\tvar _iteratorError2 = undefined;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator2 = this.tabpanelEls[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\t\tvar tabPanelEl = _step2.value;\n\t\n\t\t\t\t\t\tthis.showPanel(tabPanelEl);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// unset the bound event handlers\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t\t_iteratorError2 = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2['return']) {\n\t\t\t\t\t\t\t_iterator2['return']();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundClickHandler = undefined;\n\t\t\t\tthis.boundKeyPressHandler = undefined;\n\t\t\t\tthis.boundHashChangeHandler = undefined;\n\t\t\t\t// Destroy ALL the things!\n\t\t\t\tthis.tabEls = undefined;\n\t\t\t\tthis.tabpanelEls = undefined;\n\t\t\t\tthis.updateUrl = undefined;\n\t\t\t\tthis.selectedTabIndex = undefined;\n\t\t\t\tthis.rootEl = undefined;\n\t\t\t\tthis.config = undefined;\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'init',\n\t\t\tvalue: function init(rootEl, config) {\n\t\t\t\tif (!rootEl) {\n\t\t\t\t\trootEl = document.body;\n\t\t\t\t}\n\t\t\t\tif (!(rootEl instanceof HTMLElement)) {\n\t\t\t\t\trootEl = document.querySelector(rootEl);\n\t\t\t\t}\n\t\n\t\t\t\tif (rootEl instanceof HTMLElement && /\\bo-tabs\\b/.test(rootEl.getAttribute('data-o-component'))) {\n\t\t\t\t\tif (!rootEl.matches('[data-o-tabs-autoconstruct=false]') && !rootEl.hasAttribute('data-o-tabs--js')) {\n\t\t\t\t\t\treturn new Tabs(rootEl, config);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (rootEl.querySelectorAll) {\n\t\t\t\t\tvar tabElements = rootEl.querySelectorAll('[data-o-component=o-tabs]:not([data-o-tabs-autoconstruct=false]):not([data-o-tabs--js])');\n\t\n\t\t\t\t\treturn Array.from(tabElements, function (tabEl) {\n\t\t\t\t\t\treturn new Tabs(tabEl, config);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Tabs;\n\t})();\n\t\n\texports['default'] = Tabs;\n\tmodule.exports = exports['default'];\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=bundle.js.map"],"file":"bundle.js"}